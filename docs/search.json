[{"path":"index.html","id":"about","chapter":"1 About","heading":"1 About","text":"book gene set enrichment analysis.","code":""},{"path":"introduction.html","id":"introduction","chapter":"2 Introduction","heading":"2 Introduction","text":"…","code":""},{"path":"gene-set-databases.html","id":"gene-set-databases","chapter":"3 Gene Set Databases","heading":"3 Gene Set Databases","text":"","code":""},{"path":"gene-set-databases.html","id":"overview","chapter":"3 Gene Set Databases","heading":"3.1 Overview","text":"Gene set enrichment analysis evaluates associations gene list \ninterest collection pre-defined gene sets, gene set\nrepresents specific biological attribute. gene list \nsignificantly enriched gene set, conclusion made \ncorresponding biological function significantly affected. Thus, choosing \nproper type gene sets focusing specific topic important \nstudies. definition gene sets flexible construction \ngene sets straightforward. cases, gene sets public\ndatabases huge efforts curators already made carefully\ncategorize genes gene sets. Nevertheless, gene sets can also \nself-defined individual studies, set genes network\nmodule co-expression network analysis. chapter, introduce\nseveral major gene set databases access data R.","code":""},{"path":"gene-set-databases.html","id":"gene-ontology","chapter":"3 Gene Set Databases","heading":"3.2 Gene Ontology","text":"","code":""},{"path":"gene-set-databases.html","id":"the-go-database","chapter":"3 Gene Set Databases","heading":"3.2.1 The GO database","text":"Gene Ontology (GO) perhaps used gene set database current\nstudies. GO project started 1999. aims construct biological\nfunctions well-organized form, effciently human-reading\nmachine-reading. also provides annotations well-defined\nbiological terms multiple species, gives comprehensive knowledge\nfunctional studies.GO three namespaces (domains, ontologies), 1. biological process (BP), 2.\ncellular componet (CC) 3. molecular function (MF). describe gene \nproduct protein three aspects. Biological process describes \ngene functions biological system; Cellular components describes \nlocation cell gene performs function; Molecular function\ndescribes molecular-level activity gene. namespace, GO\nterms organized hierarchical way, form directed acyclic\ngraph (DAG). structure, parent term can multiple child terms\nchild term can multiple parent terms, loop. Also\ntop DAG, general corresponding term .relations GOGO two major parts. first part GO structure , \norganism-independent. second part GO annotation provides\nmappings GO terms genes proteins specific organism. Thus,\nGO term can linked set genes, source GO gene\nsets. easy see , due DAG strucutre GO, genes annotated\nGO terms also annotated parent term.GO rich resource. current version (2022-07-01), 43,558\nGO terms, 7 million annotations 5000 organisms. \nprovides powerful resouces studying model species, huge\nnumber species, normally gene set databases \nsupport.many gene set enrichment anlaysis, GO gene sets simply treated lists\ngenes. However, analysis, DAG structure GO also\ntaken consideration, helps reduce redundancy significant\nGO terms. Chapter x, discuss simplify GO terms taking \ninforamtion DAG structures.","code":""},{"path":"gene-set-databases.html","id":"the-go.db-package","chapter":"3 Gene Set Databases","heading":"3.2.2 The GO.db package","text":"first package introduce GO.db package. maintained\nBioconductor core team frequently updated every\nBioconductor release. Thus, always stores --date data GO can\ntreated standard source read process GO data R. GO.db\ncontains detailed information GO terms well hierarchical\nstructure GO tree. data GO.db focused GO terms\nrelations, independent specific organisms.GO.db constructed low-level package AnnotationDbi, \ndefines general database interface storing precessing biological\nannotation data. Internally GO data represented SQLite database\nmultiple tables. large number low-level functions defined \nAnnotationDbi can applied objects GO.db get customized\nfiltering GO data. Expericenced readers may go documentation \nAnnotationDbi information.First let’s load GO.db package.Simply printing object GO.db shows basic information package.\ntwo important fields source file (GOSOURCEURL) date\n(GOSOURCEDATE) build package, tell version GO data.GO.db database object created AnnotationDbi, thus, general\nmethod select() can applied retrieve data specifying vector\n“keys” list GO IDs, group “columns” \nfields values retrieved. following code, extract \nvalues \"ONTOLOGY\" \"TERM\" two GO IDs.valid columns names can obtained columns(GO.db).However, don’t really need use low-level function select() \nretrieve data. GO.db, several tables already\ncompiled can used directly. tables represented \nobjects package. following command prints variables \nexported GO.db. Note, interactive R terminal, users can also\nsee variables typing GO.db:: two continuous tabs.introduce GO-related objects, first briefly introduce \nfollowing four functions GO_dbInfo(), GO_dbconn(), GO_dbfile() \nGO_dbschema() GO.db. four functions can executed without\nargument. provides information database, e.g., GO_dbfile()\nreturns path database file.readers interested, can use external tools view GO.sqlite\nfile see internal representation database tables. However, \nreaders, internal representation data less important.\nGO.db provides easy interface processing GO data, convert data\nframes lists.First let’s look variable GOTERM. contains basic information \nevery individual GO term, GO ID, namespace definition.GOTERM object class GOTermsAnnDbBimap, child class \ngeneral class Bimap defined AnnotationDbi. Thus, many low-level\nfunctions defined AnnotationDbi can applied GOTERM (see \ndocumentation Bimap). However, suggested documentation \nGOTERM, need directly work low-level classes, \njust simply convert list.Now gl normal list GO terms. can check total number GO\nterms current version GO.db (Actually number GO terms 4.3704^{4}.\nLater section show additional pseudo term GOTERM.).can get single GO term specifying index.output printing term includes several fields corresponding\nvalues. Although gl normal list, elements still special\nclass GOTerms (try typing class(term)). GOTerms class simple class storing\ninformation individual GO terms. several “getter”\nfunctions extract values corresponding fields. important\nfunctions GOID(), Term(), Ontology(), Definition(). information\nGOTerms function can found documentation ?GOTerms., get namespaces GO terms, can :Besides working individual GO terms, getter functions can directly applied\nglobal GOTERM object extract information \nGO terms simultaneously.Now let’s go back object GOTERM. stores data GO terms, \nessentially list elements certain format. GOTERM \nclass GOTermsAnnDbBimap allows subsetting obtain subset GO terms.\ntwo types subset operators: single bracket [ double\nbrackets [[ different behaviors.Similar subset operators list, single bracket [ returns \nsubset data still keeps original format. numeric character\nindices allowed, often, character indices GO IDs used., want get information subset GO terms, can like:double-bracket operator [[ different. degenerates original\nformat directly extracts element . Note single\ncharacter index allows:behaves gl[[\"GO::0000001\"]].can calculate simple statistics GO terms, number terms\nGO namespace. Directly applying Ontology() GOTERM, easy count number GO\nterms namespace.Interestingly, besides three namespaces \"BP\", \"CC\" \"MF\", \nadditionally namespace \"universal\" contains one term. \nmentioned , three GO namespaces isolateted. However, tools\nmay require GO terms connected relations represented \ngraph. Thus, one pseudo “universal root term” added parent root\nnodes three namespaces. GO.db, special term ID\n\"\".GO.db also provides variables contains relations GO terms.\nTaking biological process namespace example, following\nfour variables (similar two namespaces, GOCC GOMF\nprefix).GOBPCHILDRENGOBPPARENTSGOBPOFFSPRINGGOBPANCESTORGOBPCHILDREN GOBPPARENTS contain parent-child relations.\nGOBPOFFSPRING contains offspring terms GO terms (.e., downstream\nterms term GO tree) GOBPANCESTOR contais ancestor terms\nGO term (.e., upstream terms term). information four\nvariables actually redudant, e.g., three objects can \nconstructed GOBPCHILDREN. However, pre-computated objects \nsave time downstream analysis traversing GO tree \ntime-consuming.four variables format (objects AnnDbBimap class, also inherts Bimap class).\nTaking GOBPCHILDREN example, directly convert list.lt simple list vectors vector child terms \nspecific GO term, e.g., GO:0000002 child term GO:0032042. \nelement vectors lt also named names represent relation \nchild term parent term. element vector value NA,\ne.g. GO::0000001, means GO term leaf GO tree, \nchild term.downstream analysis, e.g., network analysis, may expect relations \nrepresented two columns. case, can use general function\ntoTable() defined AnnotationDbi convert GOBPCHILDREN data\nframe (toTable() can also applied GOTERM. Readers can try see output toTable(GOTERM).).Unfortunately, first two columns tb name. good idea\nadd meaningful column names .Please note, previous column names valid GOBPCHILDREN. \none three GOBP* objects, readers please inspect output determine proper column names .tb, can calculate fraction different relations GO terms.Note, GOBPPARENTS GOBPANCESTOR contain universal root term \"\".can look distribution number GO terms object.Number child terms. also -degree distribution thinking GO tree graph. following plot shows -degree follows power-law distribution.Number parent terms. term “GO:0008150” (biological process) removed analysis top node BP namespace parent term.Number offspring terms. also follows power-law distribution.Number ancestor terms.Relations GOBPCHILDREN GOBPPARENTS can used construct\nGO tree “graph” “netowrk” object. remaining part section, \ndemonstrate explorary analysis show interesting attributes \nGO graph.Remember toTable() returns relations GO terms data\nframe, thus, can used “edge list” (adjacency list). \nfollowing code, use igraph package network analysis. \nfunction graph.edgelist() construct graph object two-column\nmatrix first column source link second\ncolumn target link.can extract GO term highest -degree. term largest number parents. value can also get GOBPPARENTS.\nPlease note .max() returns one index max value, mean max value.can calculate GO term highest -degree. term largest number children. value can also get GOBPCHILDREN.can explore long-disatnce attributes, distance root term every term namespace.\ndistance can thought depth term GO tree.can also extract longest path root term leaf terms.","code":"\nlibrary(GO.db)\nGO.db\n# GODb object:\n# | GOSOURCENAME: Gene Ontology\n# | GOSOURCEURL: http://current.geneontology.org/ontology/go-basic.obo\n# | GOSOURCEDATE: 2022-03-10\n# | Db type: GODb\n# | package: AnnotationDbi\n# | DBSCHEMA: GO_DB\n# | GOEGSOURCEDATE: 2022-Mar17\n# | GOEGSOURCENAME: Entrez Gene\n# | GOEGSOURCEURL: ftp://ftp.ncbi.nlm.nih.gov/gene/DATA\n# | DBSCHEMAVERSION: 2.1\nselect(GO.db, keys = c(\"GO:0000001\", \"GO:0000002\"), \n    columns = c(\"ONTOLOGY\", \"TERM\"))\n#         GOID ONTOLOGY                             TERM\n# 1 GO:0000001       BP        mitochondrion inheritance\n# 2 GO:0000002       BP mitochondrial genome maintenance\ncolumns(GO.db)\n# [1] \"DEFINITION\" \"GOID\"       \"ONTOLOGY\"   \"TERM\"\nls(envir = asNamespace(\"GO.db\"))\n#  [1] \"GO\"            \"GO.db\"         \"GOBPANCESTOR\"  \"GOBPCHILDREN\" \n#  [5] \"GOBPOFFSPRING\" \"GOBPPARENTS\"   \"GOCCANCESTOR\"  \"GOCCCHILDREN\" \n#  [9] \"GOCCOFFSPRING\" \"GOCCPARENTS\"   \"GOMAPCOUNTS\"   \"GOMFANCESTOR\" \n# [13] \"GOMFCHILDREN\"  \"GOMFOFFSPRING\" \"GOMFPARENTS\"   \"GOOBSOLETE\"   \n# [17] \"GOSYNONYM\"     \"GOTERM\"        \"GO_dbInfo\"     \"GO_dbconn\"    \n# [21] \"GO_dbfile\"     \"GO_dbschema\"\nGO_dbfile()\n# [1] \"/Users/guz/Library/R/x86_64/4.2/library/GO.db/extdata/GO.sqlite\"\nGOTERM\n# TERM map for GO (object of class \"GOTermsAnnDbBimap\")\ngl = as.list(GOTERM)\nlength(gl)\n# [1] 43705\nterm = gl[[1]]  ## also gl[[\"GO:0000001\"]]\nterm\n# GOID: GO:0000001\n# Term: mitochondrion inheritance\n# Ontology: BP\n# Definition: The distribution of mitochondria, including the\n#     mitochondrial genome, into daughter cells after mitosis or meiosis,\n#     mediated by interactions between mitochondria and the cytoskeleton.\n# Synonym: mitochondrial inheritance\nGOID(term)\n# [1] \"GO:0000001\"\nTerm(term)\n# [1] \"mitochondrion inheritance\"\nOntology(term)\n# [1] \"BP\"\nDefinition(term)\n# [1] \"The distribution of mitochondria, including the mitochondrial genome, into daughter cells after mitosis or meiosis, mediated by interactions between mitochondria and the cytoskeleton.\"\nol = sapply(gl, Ontology)\nhead(ol)\n# GO:0000001 GO:0000002 GO:0000003 GO:0000006 \n#       \"BP\"       \"BP\"       \"BP\"       \"MF\"\nhead(GOID(GOTERM))\n#   GO:0000001   GO:0000002   GO:0000003   GO:0000006 \n# \"GO:0000001\" \"GO:0000002\" \"GO:0000003\" \"GO:0000006\"\nhead(Ontology(GOTERM))\n# GO:0000001 GO:0000002 GO:0000003 GO:0000006 \n#       \"BP\"       \"BP\"       \"BP\"       \"MF\"\n# note you can also use numeric indices\nGOTERM[c(\"GO:0000001\", \"GO:0000002\", \"GO:0000003\")]\n# TERM submap for GO (object of class \"GOTermsAnnDbBimap\")\ngo_id = c(\"GO:0000001\", \"GO:0000002\", \"GO:0000003\")\nOntology(GOTERM[go_id])\n# GO:0000001 GO:0000002 GO:0000003 \n#       \"BP\"       \"BP\"       \"BP\"\n# note numeric index is not allowed\nGOTERM[[\"GO:0000001\"]]\n# GOID: GO:0000001\n# Term: mitochondrion inheritance\n# Ontology: BP\n# Definition: The distribution of mitochondria, including the\n#     mitochondrial genome, into daughter cells after mitosis or meiosis,\n#     mediated by interactions between mitochondria and the cytoskeleton.\n# Synonym: mitochondrial inheritance\ntable(Ontology(GOTERM))\n# \n#        BP        CC        MF universal \n#     28336      4183     11185         1\nwhich(Ontology(GOTERM) == \"universal\")\n#   all \n# 43705\nGOTERM[[\"all\"]]\n# GOID: all\n# Term: all\n# Ontology: universal\n# Definition: NA\nlt = as.list(GOBPCHILDREN)\nhead(lt)\n# $`GO:0000001`\n# [1] NA\n# \n# $`GO:0000002`\n#      part of \n# \"GO:0032042\" \n# \n# $`GO:0000003`\n#          isa          isa      part of          isa          isa          isa \n# \"GO:0019953\" \"GO:0019954\" \"GO:0022414\" \"GO:0032504\" \"GO:0032505\" \"GO:0075325\" \n#          isa \n# \"GO:1990277\" \n# \n# $`GO:0000011`\n# [1] NA\ntb = toTable(GOBPCHILDREN)\nhead(tb)\n#        go_id      go_id RelationshipType\n# 1 GO:0032042 GO:0000002          part of\n# 2 GO:0019953 GO:0000003              isa\n# 3 GO:0019954 GO:0000003              isa\n# 4 GO:0022414 GO:0000003          part of\ncolnames(tb)[1:2] = c(\"child\", \"parent\")\ntb = toTable(GOBPCHILDREN)\ntable(tb[, 3])\n# \n#                  isa negatively regulates              part of \n#                52089                 2753                 5048 \n# positively regulates            regulates \n#                 2742                 3197\nlt = as.list(GOBPPARENTS)\nlt[[\"GO:0008150\"]]  # GO:0008150 is \"biological process\"\n#   isa \n# \"all\"\nlt = as.list(GOBPCHILDREN)\ntb = table(sapply(lt, length))\nx = as.numeric(names(tb))\ny = as.vector(tb)\n\nlibrary(ggplot2)\nggplot(data.frame(x = x, y = y), aes(x = x, y = y)) +\n    geom_point() +\n    scale_x_continuous(trans='log10') +\n    scale_y_continuous(trans='log10') +\n    labs(x = \"Number of child terms\", y = \"Counts\") + ggtitle(\"GOBPCHILDREN\")\nlt = as.list(GOBPPARENTS)\nlt = lt[names(lt) != \"GO:0008150\"]\ntb = table(sapply(lt, length))\nx = as.numeric(names(tb))\ny = as.vector(tb)\n\nggplot(data.frame(x = x, y = y), aes(x = x, y = y)) +\n    geom_point() +\n    scale_y_continuous(trans='log10') +\n    labs(x = \"Number of parent terms\", y = \"Counts\") + ggtitle(\"GOBOPARENTS\")\nlt = as.list(GOBPOFFSPRING)\ntb = table(sapply(lt, length))\nx = as.numeric(names(tb))\ny = as.vector(tb)\n\nggplot(data.frame(x = x, y = y), aes(x = x, y = y)) +\n    geom_point() +\n    scale_x_continuous(trans='log10') +\n    scale_y_continuous(trans='log10') +\n    labs(x = \"Number of offspring terms\", y = \"Counts\") + ggtitle(\"GOBPOFFSPRING\")\nlt = as.list(GOBPANCESTOR)\nlt = lt[names(lt) != \"GO:0008150\"]\nlt = lapply(lt, function(x) setdiff(x, \"all\"))\ntb = table(sapply(lt, length))\nx = as.numeric(names(tb))\ny = as.vector(tb)\n\nggplot(data.frame(x = x, y = y), aes(x = x, y = y)) +\n    geom_point() +\n    scale_y_continuous(trans='log10') +\n    labs(x = \"Number of ancestor terms\", y = \"Counts\") + ggtitle(\"GOBPANCESTOR\")\nlibrary(igraph)\ntb = toTable(GOBPCHILDREN)\ng = graph.edgelist(as.matrix(tb[, 2:1]))\ng\n# IGRAPH 6e3c15a DN-- 28336 65829 -- \n# + attr: name (v/c)\n# + edges from 6e3c15a (vertex names):\n#  [1] GO:0000002->GO:0032042 GO:0000003->GO:0019953 GO:0000003->GO:0019954\n#  [4] GO:0000003->GO:0022414 GO:0000003->GO:0032504 GO:0000003->GO:0032505\n#  [7] GO:0000003->GO:0075325 GO:0000003->GO:1990277 GO:0000012->GO:1903516\n# [10] GO:0000012->GO:1903517 GO:0000012->GO:1903518 GO:0000012->GO:1903823\n# [13] GO:0000012->GO:1990396 GO:0000018->GO:0000019 GO:0000018->GO:0000337\n# [16] GO:0000018->GO:0010520 GO:0000018->GO:0010569 GO:0000018->GO:0045191\n# [19] GO:0000018->GO:0045910 GO:0000018->GO:0045911 GO:0000018->GO:0061806\n# [22] GO:0000018->GO:0072695 GO:0000018->GO:1903110 GO:0000019->GO:0032207\n# + ... omitted several edges\nd = degree(g, mode = \"in\")\nd_in = d[which.max(d)]\nd_in\n# GO:0106110 \n#         11\nGOTERM[[ names(d_in) ]]\n# GOID: GO:0106110\n# Term: vomitoxin biosynthetic process\n# Ontology: BP\n# Definition: The chemical reactions and pathways resulting in the\n#     formation of type B trichothecene vomitoxin, also known as\n#     deoxynivalenol, a poisonous substance produced by some species of\n#     fungi and predominantly occurs in grains such as wheat, barley and\n#     oats.\n# Synonym: deoxynivalenol biosynthetic process\n# Synonym: DON biosynthetic process\n# Synonym: vomitoxin anabolism\n# Synonym: vomitoxin biosynthesis\n# Synonym: vomitoxin formation\n# Synonym: vomitoxin synthesis\nd = degree(g, mode = \"out\")\nd_out = d[which.max(d)]\nd_out\n# GO:0048856 \n#        198\nGOTERM[[ names(d_out) ]]\n# GOID: GO:0048856\n# Term: anatomical structure development\n# Ontology: BP\n# Definition: The biological process whose specific outcome is the\n#     progression of an anatomical structure from an initial condition to\n#     its mature state. This process begins with the formation of the\n#     structure and ends with the mature structure, whatever form that\n#     may be including its natural destruction. An anatomical structure\n#     is any biological entity that occupies space and is distinguished\n#     from its surroundings. Anatomical structures can be macroscopic\n#     such as a carpel, or microscopic such as an acrosome.\n# Synonym: development of an anatomical structure\ndist = distances(g, v = \"GO:0008150\", mode = \"out\")\ntable(dist)\n# dist\n#    0    1    2    3    4    5    6    7    8    9   10   11 \n#    1   30  564 3601 7498 7992 4962 2414 1021  208   40    5\nd = degree(g, mode = \"out\")\nleave = names(d[d == 0])\nsp = shortest_paths(g, from = \"GO:0008150\", to = leave, mode = \"out\")\ni = which.max(sapply(sp$vpath, length))\npath = sp$vpath[[i]]\nTerm(GOTERM[names(path)])\n#                                                                                         GO:0008150 \n#                                                                               \"biological_process\" \n#                                                                                         GO:0008152 \n#                                                                                \"metabolic process\" \n#                                                                                         GO:0009893 \n#                                                         \"positive regulation of metabolic process\" \n#                                                                                         GO:0031325 \n#                                                \"positive regulation of cellular metabolic process\" \n#                                                                                         GO:0032270 \n#                                        \"positive regulation of cellular protein metabolic process\" \n#                                                                                         GO:0045862 \n#                                                               \"positive regulation of proteolysis\" \n#                                                                                         GO:0010952 \n#                                                        \"positive regulation of peptidase activity\" \n#                                                                                         GO:0010950 \n#                                                    \"positive regulation of endopeptidase activity\" \n#                                                                                         GO:2001056 \n#                                      \"positive regulation of cysteine-type endopeptidase activity\" \n#                                                                                         GO:0043280 \n#        \"positive regulation of cysteine-type endopeptidase activity involved in apoptotic process\" \n#                                                                                         GO:0006919 \n#                 \"activation of cysteine-type endopeptidase activity involved in apoptotic process\" \n#                                                                                         GO:0008635 \n# \"activation of cysteine-type endopeptidase activity involved in apoptotic process by cytochrome c\""},{"path":"gene-set-databases.html","id":"link-go-terms-to-genes","chapter":"3 Gene Set Databases","heading":"3.2.3 Link GO terms to genes","text":"introduced previous section, GO.db contains information GO terms.\nGO also provides gene annotated GO terms, manual curation computation prediction.\nannotations represented mappings GO IDs gene IDs external databases,\nusually synchronized major public databases NCBI.\nobtains genes GO term R, Bioconductor provides family packages name \norg.*.db. Let’s take human example, corresponding package org.Hs.eg.db.\norg.Hs.eg.db provides standard way\nprovide mappings Entrez gene IDs variaty databases.package, two database table objects mapping GO IDs genes:org.Hs.egGO2EGorg.Hs.egGO2ALLEGSThe difference two objects org.Hs.egGO2EG contains genes \ndirectly annotated every GO term, org.Hs.egGO2ALLEGS contains\ngenes directly assigned GO term, well genes assigned \nancestor terms. example term parent term B general,\ngenes function B also function . Thus org.Hs.egGO2ALLEGS \nproper object GO gene sets., org.Hs.egGO2ALLEGS database object. two ways obtain gene annotations GO terms. first \nconvert org.Hs.egGO2ALLEGS list gene vectors.case, element vector actually GO gene set. Note genes Entrez IDs, digits\ncharacter mode. Node important save Gene IDs explicitely characters get rid potential error\ndue indexing. emphasize later text.gene IDs names. evidence annotating genes GO terms.org.Hs.egGO2ALLEGS database object (also inherts Bimap class), thus toTable() can directly applied convert table.Now additional column \"Ontology\". convinient org.Hs.egGO2ALLEGS\ncontains GO terms three namespaces .list() distinguish different namespaces.tb, can look distribution number genes GO gene sets. approximately follows power-law distribution.distribution number GO gene sets gene .Biocondutor core team maintaines org.*.db 18 organismsThe org.*.db provided Bioconductor enough analysis tasks. However, may users\nmainly work non-model organism microbomens pre-compiled package Bioconductor.\ncase, can use biomaRt package get GO gene sets non-common organisms.BioMart (https://www.ensembl.org/info/data/biomart) web-based integrated sevice Ensembl database can used extract information huge number external databases.\ncompanion R package biomaRt provides programatical interface directly access BioMart purely R. Using biomaRt extract GO gene sets little bit complex\ndemonstrate step step.Connect mart (database).default, uses newest “core” Ensembl database. use organisms, readers\ncan switch another mart. supported marts can obtained function listEnsemblGenomes().need use mart “_mart” suffix. example, use fungi mart, can select\nmart :specific mart selected, need select dataset \nspecific organism. find valid value dataset,\nuse listDatasets(ensembl).datasets contains names datasets organisms supported given mart, normally long. can use regular expression match organism. example, want select dataset giant panda.name dataset first column datasets. giant panda, corresponding dataset \"amelanoleuca_gene_ensembl\". update ensembl object \nselecting dataset.Get associations genes GO terms. dataset can thought giant table, need extract columns gene GO IDs. core function getBM() extract corresponding “tables” called “attributes.” Now , need know valid attributes genes GO terms.function listAttributes(ensembl) returns supported attributes (columns) dataset.shows, attr contains 2835 rows. quite handy find\ncorrect attributes genes GO terms. Normally need try \nmatch different regular expressions. gene ID, relatively simple \nfirst row attr contains attribute name \"ensembl_gene_id\"find GO-related attributes, can try following regular expression:Now can see attribute GO IDs \"go_id\" GO namespaces \"namespace_1003\".\nselect three attributes c(\"ensembl_gene_id\", \"go_id\", \"namespace_1003\") retrieve\ndata getBM().make simple, use GO terms BP namespace convert list.Unfortunately, can directly use gs genes associated child term \nmerged parent terms. Thus, gene sets gs complete. need use\nGOBPOFFSPRING find offspring terms GO term.following code, use keys() extract GO terms offsprings. \nusing names(.list(GOBPOFFSPRING)) unique(toTable(GOBPOFFSPRING)[, 2]). GO term, take union GO term offspring (note GOBPOFFSPRING[[nm]] returns vector GO terms offspring nm), finally take genes annotated .built new R package BioMartGOGeneSets contains pre-compiled GO gene sets huge number organisms supported BioMart. readers need perform complicated steps mentioned , need execute one single function getBioMartGOGeneSets().getBioMartGOGeneSets(), readers can specify exact dataset name, string, getBioMartGOGeneSets() try match full set dataset names description select correct one.","code":"\nlibrary(org.Hs.eg.db)\nlt = as.list(org.Hs.egGO2ALLEGS)\nlt[3:4] # lt[[2]] is too long to print\n# $`GO:0000012`\n#         IGI         IDA         IDA         IDA         NAS         IDA \n#       \"142\"      \"1161\"      \"2074\"      \"3981\"      \"7014\"      \"7141\" \n#         IEA         IGI         IMP         IMP         IBA         IDA \n#      \"7515\"      \"7515\"      \"7515\"     \"23411\"     \"54840\"     \"54840\" \n#         IBA         IDA         IMP         IMP         IEA \n#     \"55775\"     \"55775\"     \"55775\"    \"200558\" \"100133315\" \n# \n# $`GO:0000017`\n#    IDA    IMP    ISS    IDA \n# \"6523\" \"6523\" \"6523\" \"6524\"\ntb = toTable(org.Hs.egGO2ALLEGS)\nhead(tb)\n#   gene_id      go_id Evidence Ontology\n# 1       1 GO:0008150       ND       BP\n# 2       2 GO:0000003      IEA       BP\n# 3       2 GO:0001553      IEA       BP\n# 4       2 GO:0001867      IDA       BP\ntb = tb[tb$Ontology == \"BP\", ]\nt1 = table(table(tb$go_id))\nx1 = as.numeric(names(t1))\ny1 = as.vector(t1)\nggplot(data.frame(x = x1, y = y1), aes(x = x, y = y)) +\n    geom_point() +\n    scale_x_continuous(trans='log10') +\n    scale_y_continuous(trans='log10') +\n    labs(x = \"Number of annotated genes\", y = \"Counts\") + ggtitle(\"GOBP\")\nt2 = table(table(tb$gene_id))\nx2 = as.numeric(names(t2))\ny2 = as.vector(t2)\nggplot(data.frame(x = x2, y = y2), aes(x = x, y = y)) +\n    geom_point() +\n    scale_x_continuous(trans='log10') +\n    scale_y_continuous(trans='log10') +\n    labs(x = \"Number of gene sets\", y = \"Counts\") + ggtitle(\"GOBP\")\nlibrary(biomaRt)\nensembl = useEnsembl(biomart = \"genes\")\nlistEnsemblGenomes()\n#               biomart                        version\n# 1       protists_mart      Ensembl Protists Genes 55\n# 2 protists_variations Ensembl Protists Variations 55\n# 3          fungi_mart         Ensembl Fungi Genes 55\n# 4    fungi_variations    Ensembl Fungi Variations 55\n# 5        metazoa_mart       Ensembl Metazoa Genes 55\n# 6  metazoa_variations  Ensembl Metazoa Variations 55\n# 7         plants_mart        Ensembl Plants Genes 55\n# 8   plants_variations   Ensembl Plants Variations 55\nensembl_fungi = useEnsemblGenomes(\"fungi_mart\")\ndatasets = listDatasets(ensembl)\ndim(datasets)\n# [1] 215   3\nhead(datasets)\n#                        dataset                           description\n# 1 abrachyrhynchus_gene_ensembl Pink-footed goose genes (ASM259213v1)\n# 2     acalliptera_gene_ensembl      Eastern happy genes (fAstCal1.2)\n# 3   acarolinensis_gene_ensembl       Green anole genes (AnoCar2.0v2)\n# 4    acchrysaetos_gene_ensembl       Golden eagle genes (bAquChr1.2)\n#       version\n# 1 ASM259213v1\n# 2  fAstCal1.2\n# 3 AnoCar2.0v2\n# 4  bAquChr1.2\nind = grep(\"panda\", datasets$description, ignore.case = TRUE)\nind\n# [1] 6\ndatasets[ind, ]\n#                     dataset                     description     version\n# 6 amelanoleuca_gene_ensembl Giant panda genes (ASM200744v2) ASM200744v2\ndataset = \"amelanoleuca_gene_ensembl\"\nensembl = useDataset(dataset = dataset, mart = ensembl)\nattr = listAttributes(ensembl)\ndim(attr)\n# [1] 2835    3\nhead(attr)\n#                            name                  description         page\n# 1               ensembl_gene_id               Gene stable ID feature_page\n# 2       ensembl_gene_id_version       Gene stable ID version feature_page\n# 3         ensembl_transcript_id         Transcript stable ID feature_page\n# 4 ensembl_transcript_id_version Transcript stable ID version feature_page\nind = grep(\"GO\", attr$description)\nind\n# [1] 33 34 35 36 37 38 39\nattr[ind, ]\n#                      name             description         page\n# 33                  go_id       GO term accession feature_page\n# 34              name_1006            GO term name feature_page\n# 35        definition_1006      GO term definition feature_page\n# 36        go_linkage_type   GO term evidence code feature_page\n# 37         namespace_1003               GO domain feature_page\n# 38   goslim_goa_accession GOSlim GOA Accession(s) feature_page\n# 39 goslim_goa_description  GOSlim GOA Description feature_page\ntb_go = getBM(attributes = c(\"ensembl_gene_id\", \"go_id\", \"namespace_1003\"), \n    mart = ensembl)\nhead(tb_go)\n#      ensembl_gene_id      go_id     namespace_1003\n# 1 ENSAMEG00000005298 GO:0004930 molecular_function\n# 2 ENSAMEG00000005298 GO:0016021 cellular_component\n# 3 ENSAMEG00000005298 GO:0007186 biological_process\n# 4 ENSAMEG00000005298 GO:0004984 molecular_function\ntb = tb_go[tb_go$namespace_1003 == \"biological_process\", , drop = FALSE]\ngs = split(tb$ensembl_gene_id, tb$go_id)\nlength(gs)\n# [1] 10763\nbp_terms = keys(GOBPOFFSPRING)\ngs2 = lapply(bp_terms, function(nm) {\n    go_id = c(nm, GOBPOFFSPRING[[nm]])\n    unique(unlist(gs[go_id]))\n})\nnames(gs2) = bp_terms\ngs2 = gs2[sapply(gs2, length) > 0]\nlibrary(BioMartGOGeneSets)\ngs = getBioMartGOGeneSets(\"amelanoleuca_gene_ensembl\", ontology = \"BP\")\ngs = getBioMartGOGeneSets(\"panda\", ontology = \"BP\")"},{"path":"gene-set-databases.html","id":"kegg-pathways","chapter":"3 Gene Set Databases","heading":"3.3 KEGG pathways","text":"Kyoto Encyclopedia Genes Genomes (KEGG) comprehensive database \ngenomic molecular data variaty organisms. sub-database \npathway database widely used gene set database used current studies.\nKEGG, pathways manually curated number genes pathways \nintermediateKeep mind, KEGG cann support maintainness, KEGG pathways free academic users.","code":""},{"path":"gene-set-databases.html","id":"kegg-api","chapter":"3 Gene Set Databases","heading":"3.3.1 KEGG API","text":"KEGG provides data via REST API (https://rest.kegg.jp/). \nseveral commands can used retrieve specific types data. URL form request isTo get KEGG pathway gene sets, use operator link list.link operator returns mapping two sources information. can use\nfollowing command get mappings genes pathways human.example, url() construct connection object directly transfer\ndata remote URL. output, first column contains Entrez ID\n(users may remove \"hsa:\" prefix downstream analysis) second\ncolumncontains KEGG pathways IDs (users may remove \"path:\" previx).get full name pathways, use list command:KEGG pathways categorized groups:","code":"https://rest.kegg.jp/<operation>/<argument>[/<argument2[/<argument3> ...]]\ndf1 = read.table(url(\"https://rest.kegg.jp/link/pathway/hsa\"), \n    sep = \"\\t\")\nhead(df1)\n#          V1            V2\n# 1 hsa:10327 path:hsa00010\n# 2   hsa:124 path:hsa00010\n# 3   hsa:125 path:hsa00010\n# 4   hsa:126 path:hsa00010\ndf2 = read.table(url(\"https://rest.kegg.jp/list/pathway/hsa\"), \n    sep = \"\\t\")\nhead(df2)\n#              V1                                                              V2\n# 1 path:hsa00010             Glycolysis / Gluconeogenesis - Homo sapiens (human)\n# 2 path:hsa00020                Citrate cycle (TCA cycle) - Homo sapiens (human)\n# 3 path:hsa00030                Pentose phosphate pathway - Homo sapiens (human)\n# 4 path:hsa00040 Pentose and glucuronate interconversions - Homo sapiens (human)"},{"path":"gene-set-databases.html","id":"packages","chapter":"3 Gene Set Databases","heading":"3.3.2 Packages","text":"two Bioconductor packages retrieving pathway data KEGG. based KEGG REST API. first one package KEGGREST \nimplements full interface access KEGG data R. API KEGG REST service suppoted KEGGREST. example, get mapping\ngenes pathways, function keggLink() can used.returned object pathway2gene named vector, names corresponding source values correspond target. Readers can try \nexecute keggLink(\"hsa\", \"pathway\") compare results.named vectors common downstream gene set analysis. used format data frame. can simply converted :pathway ID, prefix letters corresponds organism, e.g. hsa human.\nget list pathway names:Last least, another useful function KEGGREST keggGet() implements get command REST API. function users can download\nimages KGML pathways.However, conf file supported keggGet(). Users need directly read URLThe conf file contains coordinate genes nodes image. useful users want highlight genes image.example, want highlight ninth row confThis rectangle two diagnols [142, 287] [188, 304]. coordinates,\ncan find position image later add rectangle .note since coordinate starts teh top left corner plot, plotting\ncoordinate, starts bottom left.second Bioconductor pacakge clusterProfiler simple function download_KEGG() accepts prefix organism returns list two data frames,\none mapping genes pathways full name pathways.two packages mentioned provide data teh network representation pathways. Chapter x demonstrate read process pathways networks. \nsimply treat pathways lists genes ignore relations genes .","code":"\nlibrary(KEGGREST)\npathway2gene = keggLink(\"pathway\", \"hsa\")\nhead(pathway2gene)\n#       hsa:10327         hsa:124         hsa:125         hsa:126 \n# \"path:hsa00010\" \"path:hsa00010\" \"path:hsa00010\" \"path:hsa00010\"\np2g_df = data.frame(gene_id = gsub(\"hsa:\", \"\", names(pathway2gene)),\n    pathway_id = gsub(\"path:\", \"\", pathway2gene))\nhead(p2g_df)\n#   gene_id pathway_id\n# 1   10327   hsa00010\n# 2     124   hsa00010\n# 3     125   hsa00010\n# 4     126   hsa00010\nhead(keggList(\"pathway\", \"hsa\"))\n#                                                     path:hsa00010 \n#             \"Glycolysis / Gluconeogenesis - Homo sapiens (human)\" \n#                                                     path:hsa00020 \n#                \"Citrate cycle (TCA cycle) - Homo sapiens (human)\" \n#                                                     path:hsa00030 \n#                \"Pentose phosphate pathway - Homo sapiens (human)\" \n#                                                     path:hsa00040 \n# \"Pentose and glucuronate interconversions - Homo sapiens (human)\"\nimg = keggGet(\"hsa05310\", \"image\")\nkkgml = keggGet(\"hsa05310\", \"kgml\")\nconf = read.table(url(\"https://rest.kegg.jp/get/hsa05310/conf\"),\n    sep = \"\\t\")\nconf[9, ]\n#                         V1\n# 9 rect (142,287) (188,304)\n#                                                                                 V2\n# 9 /dbget-bin/www_bget?hsa:3108+hsa:3109+hsa:3111+hsa:3112+hsa:3113+hsa:3115+hsa:..\n#                                                                                 V3\n# 9 3108 (HLA-DMA), 3109 (HLA-DMB), 3111 (HLA-DOA), 3112 (HLA-DOB), 3113 (HLA-DPA1..\nlibrary(grid)\n\nimg_width = dim(img)[2]\nimg_height = dim(img)[1]\npushViewport(viewport(xscale = c(1, img_width), yscale = c(1, img_height),\n    width = unit(img_width/img_height, \"snpc\"), height = unit(1, \"snpc\")))\ngrid.raster(img)\ngrid.rect(x = 142+1, y = img_height - 304, width = 188-142, height = 304-287, \n    default.units = \"native\", just = c(\"left\", \"bottom\"),\n    gp = gpar(col = \"red\", fill = NA, lwd = 2))\npopViewport()\nlt = clusterProfiler::download_KEGG(\"hsa\")\nhead(lt$KEGGPATHID2EXTID)\n#       from    to\n# 1 hsa00010 10327\n# 2 hsa00010   124\n# 3 hsa00010   125\n# 4 hsa00010   126\nhead(lt$KEGGPATHID2NAME)\n#       from                                       to\n# 1 hsa00010             Glycolysis / Gluconeogenesis\n# 2 hsa00020                Citrate cycle (TCA cycle)\n# 3 hsa00030                Pentose phosphate pathway\n# 4 hsa00040 Pentose and glucuronate interconversions"},{"path":"gene-set-databases.html","id":"reactome-pathways","chapter":"3 Gene Set Databases","heading":"3.4 Reactome pathways","text":"Reactome another popular pathway database. organise pathways hierarchical category, contains pathways sub pathways\npathway components. --date pathway data can direclty found https://reactome.org/download-data.reactome.db Bioconductor. Similar annotation packages. Users can type reactome.db:: two continuous tabs see objects\nsupported package. , important objects arereactomePATHID2EXTID contains mappings reacotme pathway IDs gene entrez IDsreactomePATHID2NAME contains pathway namesIn previous code, use function toTable() retrieve data data frames. Readers may try .list() two objects compare output.Reactome also contains pathway multiple organisms. reactome ID, teh second section contains organism, e.g. previous output HSA., reactome.db contains pathways list genes.Recall previous section clusterProfiler, two elements object lt named \nKEGGPATHID2EXTID KEGGPATHID2NAME, howevery two simply data frames. name object really imply internal structure. always recommeneded print object see structure.","code":"\nlibrary(reactome.db)\ntb = toTable(reactomePATHID2EXTID)\nhead(tb)\n#          DB_ID gene_id\n# 1 R-HSA-109582       1\n# 2 R-HSA-114608       1\n# 3 R-HSA-168249       1\n# 4 R-HSA-168256       1\np2n = toTable(reactomePATHID2NAME)\nhead(p2n)\n#           DB_ID\n# 1   R-BTA-73843\n# 2 R-BTA-1971475\n# 3 R-BTA-1369062\n# 4  R-BTA-382556\n#                                                                     path_name\n# 1                                              1-diphosphate: 5-Phosphoribose\n# 2 Bos taurus: A tetrasaccharide linker sequence is required for GAG synthesis\n# 3                           Bos taurus: ABC transporters in lipid homeostasis\n# 4                          Bos taurus: ABC-family proteins mediated transport\ntable( gsub(\"^R-(\\\\w+)-\\\\d+$\", \"\\\\1\", p2n[, 1]) )\n# \n#  BTA  CEL  CFA  DDI  DME  DRE  GGA  HSA  MMU  MTU  PFA  RNO  SCE  SPO  SSC  XTR \n# 1691 1299 1653  979 1473 1671 1703 2585 1710   13  595 1697  809  816 1656 1576"},{"path":"gene-set-databases.html","id":"msigdb","chapter":"3 Gene Set Databases","heading":"3.5 MSigDB","text":"Molecular signature database mauanlly curated gene set databases. Initially, proposed comparion dataset original GSEA paper. Later separated developed independently. first version 2005, xx gene set categories total xx gene sets. Now newest version MisgDb, xx gene sets total xx gene sets. provides gene sets focusing various aspects xxx.MsigDb website already provide gene sets text-based files, easy parse. Taking original c2 gene sets catague example. gene sets stored file .gmt format. gmt format follows:read gmt fileWhich species supported. Please note MSigDB provides gene sets human,\nmsigdbr supports species annotating homologous genes.obtain gene sets:categories gene sets:E.g., want extract genesets C2 category CP:KEGG sub-category:","code":"gene_set_1  gene set description    gene1   gene2   gene3\ngene_set_2  gene set description    gene4   gene5\n...\nln = readLines(\"data/c2.symbols.gmt\")\nln = strsplit(ln, \"\\t\")\ngs = lapply(ln, function(x) x[-(1:2)])\nnames(gs) = sapply(ln, function(x) x[1])\nlibrary(msigdbr)\nmsigdbr_species()\n# # A tibble: 20 × 2\n#    species_name                    species_common_name                          \n#    <chr>                           <chr>                                        \n#  1 Anolis carolinensis             Carolina anole, green anole                  \n#  2 Bos taurus                      bovine, cattle, cow, dairy cow, domestic cat…\n#  3 Caenorhabditis elegans          <NA>                                         \n#  4 Canis lupus familiaris          dog, dogs                                    \n#  5 Danio rerio                     leopard danio, zebra danio, zebra fish, zebr…\n#  6 Drosophila melanogaster         fruit fly                                    \n#  7 Equus caballus                  domestic horse, equine, horse                \n#  8 Felis catus                     cat, cats, domestic cat                      \n#  9 Gallus gallus                   bantam, chicken, chickens, Gallus domesticus \n# 10 Homo sapiens                    human                                        \n# 11 Macaca mulatta                  rhesus macaque, rhesus macaques, Rhesus monk…\n# 12 Monodelphis domestica           gray short-tailed opossum                    \n# 13 Mus musculus                    house mouse, mouse                           \n# 14 Ornithorhynchus anatinus        duck-billed platypus, duckbill platypus, pla…\n# 15 Pan troglodytes                 chimpanzee                                   \n# 16 Rattus norvegicus               brown rat, Norway rat, rat, rats             \n# 17 Saccharomyces cerevisiae        baker's yeast, brewer's yeast, S. cerevisiae \n# 18 Schizosaccharomyces pombe 972h- <NA>                                         \n# 19 Sus scrofa                      pig, pigs, swine, wild boar                  \n# 20 Xenopus tropicalis              tropical clawed frog, western clawed frog\nall_gene_sets = msigdbr() # by default it is human\ndim(all_gene_sets)\n# [1] 4331807      15\nhead(all_gene_sets)\n# # A tibble: 4 × 15\n#   gs_cat gs_subcat gs_name gene_…¹ entre…² ensem…³ human…⁴ human…⁵ human…⁶ gs_id\n#   <chr>  <chr>     <chr>   <chr>     <int> <chr>   <chr>     <int> <chr>   <chr>\n# 1 C3     MIR:MIR_… AAACCA… ABCC4     10257 ENSG00… ABCC4     10257 ENSG00… M126…\n# 2 C3     MIR:MIR_… AAACCA… ABRAXA…   23172 ENSG00… ABRAXA…   23172 ENSG00… M126…\n# 3 C3     MIR:MIR_… AAACCA… ACTN4        81 ENSG00… ACTN4        81 ENSG00… M126…\n# 4 C3     MIR:MIR_… AAACCA… ACTN4        81 ENSG00… ACTN4        81 ENSG00… M126…\n# # … with 5 more variables: gs_pmid <chr>, gs_geoid <chr>,\n# #   gs_exact_source <chr>, gs_url <chr>, gs_description <chr>, and abbreviated\n# #   variable names ¹​gene_symbol, ²​entrez_gene, ³​ensembl_gene,\n# #   ⁴​human_gene_symbol, ⁵​human_entrez_gene, ⁶​human_ensembl_gene\n# # ℹ Use `colnames()` to see all variable names\nas.data.frame(head(all_gene_sets))\n#   gs_cat      gs_subcat        gs_name gene_symbol entrez_gene    ensembl_gene\n# 1     C3 MIR:MIR_Legacy AAACCAC_MIR140       ABCC4       10257 ENSG00000125257\n# 2     C3 MIR:MIR_Legacy AAACCAC_MIR140    ABRAXAS2       23172 ENSG00000165660\n# 3     C3 MIR:MIR_Legacy AAACCAC_MIR140       ACTN4          81 ENSG00000130402\n# 4     C3 MIR:MIR_Legacy AAACCAC_MIR140       ACTN4          81 ENSG00000282844\n#   human_gene_symbol human_entrez_gene human_ensembl_gene  gs_id gs_pmid\n# 1             ABCC4             10257    ENSG00000125257 M12609        \n# 2          ABRAXAS2             23172    ENSG00000165660 M12609        \n# 3             ACTN4                81    ENSG00000130402 M12609        \n# 4             ACTN4                81    ENSG00000282844 M12609        \n#   gs_geoid gs_exact_source gs_url\n# 1                                \n# 2                                \n# 3                                \n# 4                                \n#                                                                     gs_description\n# 1 Genes having at least one occurence of the motif AAACCAC in their 3' untransla..\n# 2 Genes having at least one occurence of the motif AAACCAC in their 3' untransla..\n# 3 Genes having at least one occurence of the motif AAACCAC in their 3' untransla..\n# 4 Genes having at least one occurence of the motif AAACCAC in their 3' untransla..\nas.data.frame(msigdbr_collections())\n#    gs_cat       gs_subcat num_genesets\n# 1      C1                          299\n# 2      C2             CGP         3384\n# 3      C2              CP           29\n# 4      C2     CP:BIOCARTA          292\n# 5      C2         CP:KEGG          186\n# 6      C2          CP:PID          196\n# 7      C2     CP:REACTOME         1615\n# 8      C2 CP:WIKIPATHWAYS          664\n# 9      C3       MIR:MIRDB         2377\n# 10     C3  MIR:MIR_Legacy          221\n# 11     C3        TFT:GTRD          518\n# 12     C3  TFT:TFT_Legacy          610\n# 13     C4             CGN          427\n# 14     C4              CM          431\n# 15     C5           GO:BP         7658\n# 16     C5           GO:CC         1006\n# 17     C5           GO:MF         1738\n# 18     C5             HPO         5071\n# 19     C6                          189\n# 20     C7     IMMUNESIGDB         4872\n# 21     C7             VAX          347\n# 22     C8                          700\n# 23      H                           50\ngene_sets = msigdbr(category = \"C2\", subcategory = \"CP:KEGG\")\ngene_sets\n# # A tibble: 16,283 × 15\n#    gs_cat gs_sub…¹ gs_name gene_…² entre…³ ensem…⁴ human…⁵ human…⁶ human…⁷ gs_id\n#    <chr>  <chr>    <chr>   <chr>     <int> <chr>   <chr>     <int> <chr>   <chr>\n#  1 C2     CP:KEGG  KEGG_A… ABCA1        19 ENSG00… ABCA1        19 ENSG00… M119…\n#  2 C2     CP:KEGG  KEGG_A… ABCA10    10349 ENSG00… ABCA10    10349 ENSG00… M119…\n#  3 C2     CP:KEGG  KEGG_A… ABCA12    26154 ENSG00… ABCA12    26154 ENSG00… M119…\n#  4 C2     CP:KEGG  KEGG_A… ABCA13   154664 ENSG00… ABCA13   154664 ENSG00… M119…\n#  5 C2     CP:KEGG  KEGG_A… ABCA2        20 ENSG00… ABCA2        20 ENSG00… M119…\n#  6 C2     CP:KEGG  KEGG_A… ABCA3        21 ENSG00… ABCA3        21 ENSG00… M119…\n#  7 C2     CP:KEGG  KEGG_A… ABCA4        24 ENSG00… ABCA4        24 ENSG00… M119…\n#  8 C2     CP:KEGG  KEGG_A… ABCA5     23461 ENSG00… ABCA5     23461 ENSG00… M119…\n#  9 C2     CP:KEGG  KEGG_A… ABCA6     23460 ENSG00… ABCA6     23460 ENSG00… M119…\n# 10 C2     CP:KEGG  KEGG_A… ABCA7     10347 ENSG00… ABCA7     10347 ENSG00… M119…\n# # … with 16,273 more rows, 5 more variables: gs_pmid <chr>, gs_geoid <chr>,\n# #   gs_exact_source <chr>, gs_url <chr>, gs_description <chr>, and abbreviated\n# #   variable names ¹​gs_subcat, ²​gene_symbol, ³​entrez_gene, ⁴​ensembl_gene,\n# #   ⁵​human_gene_symbol, ⁶​human_entrez_gene, ⁷​human_ensembl_gene\n# # ℹ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names"},{"path":"gene-set-databases.html","id":"uniprot-keywords","chapter":"3 Gene Set Databases","heading":"3.6 UniProt keywords","text":"","code":"\nlibrary(UniProtKeywords)\ngl = load_keyword_genesets(9606)"},{"path":"gene-set-databases.html","id":"other-databases","chapter":"3 Gene Set Databases","heading":"3.7 Other databases","text":"","code":""},{"path":"gene-set-databases.html","id":"do","chapter":"3 Gene Set Databases","heading":"3.7.1 DO","text":"","code":""},{"path":"gene-set-databases.html","id":"mesh","chapter":"3 Gene Set Databases","heading":"3.7.2 MeSH","text":"","code":""},{"path":"gene-set-databases.html","id":"pathway-common","chapter":"3 Gene Set Databases","heading":"3.7.3 Pathway Common","text":"","code":""},{"path":"gene-set-databases.html","id":"other-sources","chapter":"3 Gene Set Databases","heading":"3.7.4 other sources","text":"pathway databases, …DOMeshpathway commonother …","code":""},{"path":"gene-set-databases.html","id":"gene-id-mapping","chapter":"3 Gene Set Databases","heading":"3.8 Gene ID mapping","text":"perform gene set enrichment analysis, always two sources data, one genes one gene sets. Thus,\ngene IDs two sources may . ThusThanks Bioconductor annotation ecosystem, org.*.eg.db family packages provide annotation sources genes\nvarious databases, take org.Hs.eg.db package exampleThe second widely used package gene ID coversion biomart package uses service ensemble biomart service.also helper functions implemented packages using xxx. bitr() uses org.db packages gene ID coversion. returns\ntwo-column data mapping. However, users need set type , values can obtained columns(org.Hs.eg.db)comparion package book, implemented function convert_to_entrez_id(), automatically recognize\ninput gene ID type convert Entrez ID since almost gene set database provide genes Entrez IDs. function \nused book. can recognize following input types:character vectora numeric vector gene names namesa matrix gene names row names.last two scenarios, multple genes mapped single Entrez ID, corresponding elements rows averaged.","code":"\nkeytypes(org.Hs.eg.db)\n#  [1] \"ACCNUM\"       \"ALIAS\"        \"ENSEMBL\"      \"ENSEMBLPROT\"  \"ENSEMBLTRANS\"\n#  [6] \"ENTREZID\"     \"ENZYME\"       \"EVIDENCE\"     \"EVIDENCEALL\"  \"GENENAME\"    \n# [11] \"GENETYPE\"     \"GO\"           \"GOALL\"        \"IPI\"          \"MAP\"         \n# [16] \"OMIM\"         \"ONTOLOGY\"     \"ONTOLOGYALL\"  \"PATH\"         \"PFAM\"        \n# [21] \"PMID\"         \"PROSITE\"      \"REFSEQ\"       \"SYMBOL\"       \"UCSCKG\"      \n# [26] \"UNIPROT\""},{"path":"gene-set-databases.html","id":"data-structure","chapter":"3 Gene Set Databases","heading":"3.9 Data structure","text":"Currently widely-accepted standard format general gene set representation. demonstrated,\ngene sets can represetnted two-column data frame row contains gene gene set. ALternatively, \ncan easily converted teh two-column data frame list element list vector genes.early days bioconductor dealling microarray data, GSEAbase package bioconductor core team,\nxxx.BiocSet","code":""},{"path":"over-representation-analysis.html","id":"over-representation-analysis","chapter":"4 Over-Representation Analysis","heading":"4 Over-Representation Analysis","text":"","code":""},{"path":"over-representation-analysis.html","id":"overview-1","chapter":"4 Over-Representation Analysis","heading":"4.1 Overview","text":"-representation analysis (ORA) uses simplified model gene set\nenrichment anlaysis. directly works counts genes different categories,\n.e., whether genes list interest whether genes gene set.\nsimplicity, ORA mostly used method gene set enrichment analysis.\nchapter, introduce different tests ORA implementations R.\nalso point limitations ORA users need careful \napply ORA datasets.","code":""},{"path":"over-representation-analysis.html","id":"what-is-over-representation","chapter":"4 Over-Representation Analysis","heading":"4.2 What is over-representation?","text":"many cases, ORA applied list differentially expressed\ngenes, thus, make readers read chapter naturally, use\n“differentially expressed genes” represent list genes interest. please\nkeep mind differential genes just special case gene list. applications,\ncan kind gene lists.gene denoted \\(G\\), two attributes: whether differentially expressed\n(DE) whether belongs gene set. two relations can represented \nVenn Diagram (Figure @ref(fig:ora_venn)). denote \\(p_1\\) \nprobability \\(G\\) differentially expressed, \\(p_2\\) \nprobability \\(G\\) gene set, \\[ p_1 = n_{\\mathrm{diff}}/n \\]\n\\[ p_2 = n_{\\mathrm{set}}/n \\]\\(n_{\\mathrm{diff}}\\) number DE genes, \\(n_{\\mathrm{set}}\\) \nnumber genes gene set, \\(n\\) total number genes \nstudy. Assume two attributes \\(G\\) independent, .e., whether genes\nDE preference whether genes gene set, \nexpected number DE genes also gene set \\(n p_1 p_2\\). Denote \nobserved number DE genes gene set \\(m\\), can calculate ratio \\(r = m/n p_1 p_2\\). observed genes gene set expected,\n.e., \\(r > 1\\), say DE genes -represented gene set, \nidentically, can say genes gene set -represented DE genes. \\(r < 1\\), say DE genes -represented\ngene set.quick calculation shows\\[ r = \\frac{m}{n p_1 p_2} = \\frac{m n}{n_{\\mathrm{diff}} n_{\\mathrm{set}}} \\]can look problem slightly different aspect. treat \\(p_1\\) previously defined \n“background probability” gene DE. also calculate probability\ngenes DE gene set, term “foreground probability” denote \\(p^\\mathrm{fore}_1\\):\\[ p^\\mathrm{fore}_1 = m/n_{\\mathrm{set}} \\]foreground probability higher background probability, .e., \\(p^\\mathrm{fore}_1 > p_1\\)\n\\(p^\\mathrm{fore}_1 / p_1 > 1\\), can say DE genes -represented gene set. easy see\\[ \\frac{P'_1}{P_1} = \\frac{m n}{n_{\\mathrm{diff}} n_{\\mathrm{set}}} \\].Similarly, can treat \\(p_2\\) “background probability” genes gene set,\ncalculate “foreground probability” gene gene set, DE genes, denoted \\(p^\\mathrm{fore}_2\\):\\[ p^\\mathrm{fore}_2 = m/n_{\\mathrm{diff}}\\]easy see \\(p^\\mathrm{fore}_2/p_2\\) identical \\(p^\\mathrm{fore}_1/p_1\\)score \\(r\\) can used measures whether DE genes \n-represented gene set, higher value \\(r\\) implies stronger\n-representation. statistical procedures, need statistical test calculate p-value\n-representation assign “signficance level” enrichment.\nAlthough \\(r\\) able measure -representation, distribution analytical form hard obtain.\nnext section, introduce \nspecific distributions statistical tests calculating p-values.","code":""},{"path":"over-representation-analysis.html","id":"statistical-tests","chapter":"4 Over-Representation Analysis","heading":"4.3 Statistical tests","text":"","code":""},{"path":"over-representation-analysis.html","id":"hypergeometric-distribution","chapter":"4 Over-Representation Analysis","heading":"4.3.1 Hypergeometric distribution","text":"Hypergeometric distribution xxx discrete events. first briefly introduce \nform hypergenometric map xxx ORA analysis.problem can formulated follows. Assume \\(N\\) balls bag, \\(K\\) red balls, \n\\(N - K\\) blue balls. randomly picking \\(n\\) balls without replacement (ball picked, put back), probability \\(k\\) red balls \\(n\\) balls?Also assume independent pick ball, , can following numbers:Total number combinations picking \\(n\\) balls bag: \\(\\binom{N}{n}\\).Number combinations pick \\(k\\) red balls \\(K\\) red balls: \\(\\binom{K}{k}\\).Number combinations picking \\(n-k\\) blue balls \\(N-K\\) blue balls: \\(\\binom{N-K}{n-k}\\).Since picking red balls picking blue balls independent, number combinations picking \\(n\\) balls contain \\(k\\) red\n\\(n-k\\) blue balls \\(\\binom{K}{k} \\binom{N-K}{n-k}\\), probability denoted \\(P_{\\mathrm{hyper}}\\) calculated :\\[ P_{\\mathrm{hyper}} = \\frac{\\binom{K}{k} \\binom{N-K}{n-k}}{\\binom{N}{n}}\\].Let’s denote number red balls random variable \\(X\\), \\(X\\) follows hypergenometric distribution parameters\n\\(N\\), \\(K\\) \\(n\\), written \\(X \\sim \\mathrm{Hyper}(N, K, n)\\).Now can map ORA analysis. , use commonly used denotations literatures.ORA basically form ball problem. just need change terms \nstatistical model unchanged. E.g. change red balls DE genes blue balls non-DE genes.\nballs pick genes gene set. full map Table x.Specifically ORA, denote number DE genes gene set random variable \\(X\\), \\[ X \\sim \\mathrm{Hyper}(n, n_{1+}, n_{+1}) \\]\\(n_{11}\\) big, whether gene id DE whether gene gene set highly dependent, \nwords, DE genes -represented gene set. random variable \\(X\\), p-value\ncalculated \\(Pr(X \\geq n_{11})\\) probability X less \\(n_{11}\\). p-value \nsmall, observed \\(X = n_{11}\\), can say, rare event happens p-value signficant.\\[ Pr( X >= n_11 ) = 1 - Pr(X < n_11) = 1 - \\sum_{x \\{0, .., {n_11 - 1}}} p(x, n_{+1}, n_{1+}, n)\\]","code":""},{"path":"over-representation-analysis.html","id":"binomial-distribution","chapter":"4 Over-Representation Analysis","heading":"4.3.2 Binomial distribution","text":"\\(n_{1+}\\) \\(n_{+1}\\) \\(n\\) large, \nhypergenometric distribution can approximated Binomial test. Now \nneed change question little bit. Now look genes gene set.\ngene set \\(n_{+1}\\) genes, gene can DE genes probabilty \\(p_{diff}\\).\nprobability observing \\(n_{11}\\) DE genes. First \\(p_{\\mathrm{diff}}\\) estimated \\[p_{\\mathrm{diff}} = n_{1+}/n \\]probelm can thought pick ball \\(n_{+1}\\) times, number picking \\(n_{11}\\) balls \\(\\binom{n_{+1}}{n_{11}}\\).\nprobability \\(n_{11}\\) balls DE \\(p_{\\mathrm{diff}}^{n_{11}}\\) \\(n_{+1} - n_{11}\\) balls\nDE \\((1-p_{\\mathrm{diff}})^{n_{+1} - n_{11}}\\), final probability \\[ p =  \\binom{n_{+1}}{n_{11}} p_{\\mathrm{diff}}^{n_{11}} (1-p_{\\mathrm{diff}})^{n_{+1} - n_{11}} \\], denote number DE genes gene set random variable \\(X\\), \\(X \\sim \\mathrm{Binom}(n_{+1}, p_{\\mathrm{diff}})\\).p-value calculated \\(Pr(X \\geq n_{11})\\).can also direction, look DE genes gene probability gene set.\\[p_{\\mathrm{set}} = n_{+1}/n\\]approximatedly, \\(X \\sim \\mathrm{Binom}(n_{1+}, p_{\\mathrm{set}})\\). note, two p-values identical.","code":""},{"path":"over-representation-analysis.html","id":"z-test","chapter":"4 Over-Representation Analysis","heading":"4.3.3 z-test","text":"Let’s look back Table xx, two events “genes DE” “gene gene set” independent, probability\ngene DE gene set identical probability gene DE gene set, \nfollowing two probabilities:\\[ p_1 = n_{11}/n_{+1} \\]\n\\[ P_2 = n_{12}/n_{+2} \\]genes gene set, number DE genes actually follow Binomilal distribution \\(\\mathrm{Binom}(n_{+1}, p_1)\\),\ngenes gene set, number DE genes also follow Binomial distribution: \\(\\mathrm{Binom}(n_{+2}, p_2)\\).\nNow problem test whether two Binomial distribution idential. null hypothesis \\(p_1 = p_2\\), \n\\(n_{+1}\\) \\(n_{+2}\\) large, following z-score:\\[z = \\frac{p_1 - p_2}{\\sqrt{p(1-p)} \\sqrt{\\frac{1}{n_{1+}} + \\frac{1}{n_{2+}}}}\\]\\(p = \\frac{n_{11}+n_{12}}{n_{+1} + n_{+2}} = \\frac{n_{1+}}{n}\\). \\(z\\) follows standard normal distribution \\(N(0,1)\\).easy see test idential \\(p_1\\) \\(p_2\\) calculated probabilities genes \ngene set, DE genes non-DE genes.","code":""},{"path":"over-representation-analysis.html","id":"fishers-exact-test","chapter":"4 Over-Representation Analysis","heading":"4.3.4 Fisher’s exact test","text":"Fisher’s exact test can used ","code":""},{"path":"over-representation-analysis.html","id":"chi-square-test","chapter":"4 Over-Representation Analysis","heading":"4.3.5 Chi-square test","text":"Pearson’s Chi-square test can also applied test whether dependencies categorized data. Chi-square\nstatistic measures relative sum squares difference observed values expected categories:\\[ \\chi^2 = \\sum_i \\frac{ (O_i - E_i)^2 }{E_i} \\]\\(O_i\\) observed value category \\(\\) \\(E_i\\) expected value category \\(\\).apply 2x2 contigency table, actually data splt four non-intersected categories, DE/set, DE/set,\nnon-DE/set non-DE/set. Let’s take first category, e.g. genes DE also set,\nobserved value simply \\(n_{11}\\). expected value \\(n p_{1+} p_{+1}\\) assumes whether gene\nDE whether gene set independent, \\(p_{1+} = n_{1+}/n\\) \\(p_{+1} = n_{+1}/n\\). \nwrite four categories, \\[ \\chi^2 = \\sum_{=1}^2 \\sum_{j=1}^2 \\frac{(n_{ij} - n p_{+} p_{+j})^2}{n p_{+} p_{+j}} \\]\\(p_{+} = n_{+}/n\\) \\(p_{+j} = n_{+j}/n\\).\\(n\\) large, \\(\\chi^2\\) statistic can approximated followinng \\(\\chi^2\\) distribution degree freedom 1.Simply calcus reveals value \\(\\chi^2\\) square z-statistic.","code":""},{"path":"over-representation-analysis.html","id":"calculate-in-r","chapter":"4 Over-Representation Analysis","heading":"4.4 Calculate in R","text":"demonstrate different distributions tests, use data fro EBI Altas database\naccession ID E-GEOD-101794. difffernetial expression analysis, 968\negnes differential cutoff FDR < 0.05, total number genes 38592, \nuse gene set named “HALLMARK_KRAS_SIGNALING_DN” fro MsigDb database contains 200 genes.\n2x2 contigency table followsThe function phyper() calculates p-value hypergeometric distribution. usage \nphyer() :ORA, q number differnetial genes gene set, m size gene set,\nn number genes gene set, k number differnetial genes. since hypergeometric can also calcualted dimension, m can number differneital genes, n number non-diff genes k number genes gene set.default phyper() calculates probabilty Pr(X <= q)Note asP-value Binominal distribution can calcualted function pbinom(). usage isTo calculate z-test, first calculate p1 p2Since z follows standard normal distribution, can use pnorm() calcualte p-value:can also try calculate p-valeu direction. similarly,two p-values identical.Fisher’s exact test can directly performed function fisher.test(). input 2x2 contigency table without margins.fisher.test() generates many results, odd ratio statistic fisher exact test. odd ratio defined \\[ \\mathrm{odd ratio} = \\frac{n_{11}}{n_{21}} / \\frac{n_{11}}{n_{22}} = \\frac{n_{11}n_{22}}{n_{12}n_{21}} \\]ratio fraction DE gene set gene set. odd ratio larger 1, -representation.Last, Chi-square test can applied function chisq.test(). Similarly input 2x2 contigency table without margins. Note also set correct = FALSE …Since several ways perform test, interesting test method runs faster.can see benchmark result, hypergeometric bionimal distribution-based method fastest. comparison,\nChi-square test fisher’s method run slow, especially fisher’s exact method. reason latter two also include\nmany calculations besides p-values. benchmark results actually tells us, future readers want implement\nORA analysis , hypergeometric bimonial methods considered firstly.","code":"\nphyper(q, m, n, k)\n1 - phyper(14 - 1, 200, 38392, 968)\n# [1] 0.0005686084\nphyper(14 - 1, 200, 38392, 968, lower.tail = FALSE)\n# [1] 0.0005686084\n1 - phyper(14 - 1, 968, 37624, 200)\n# [1] 0.0005686084\npbinom(q, size, prob)\n1 - pbinom(14 - 1, 200, 968/38592)\n# [1] 0.0005919725\n1 - pbinom(14 - 1, 968, 200/38592)\n# [1] 0.0006924557\np1 = 14/200\np2 = 954/38392\np = 968/38592\n\nz = abs(p1 - p2)/sqrt(p * (1-p))/sqrt(1/200 + 1/38392)\n2*pnorm(z, lower.tail = FALSE)\n# [1] 4.647219e-05\np1 = 14/968\np2 = 186/37624\np = 200/38592\n\nz = abs(p1 - p2)/sqrt(p * (1-p))/sqrt(1/968 + 1/37624)\n2*pnorm(z, lower.tail = FALSE)\n# [1] 4.647219e-05\ncm = matrix(c(14, 186, 954, 37438), nrow = 2)\ncm\n#      [,1]  [,2]\n# [1,]   14   954\n# [2,]  186 37438\nfisher.test(cm)\n# \n#   Fisher's Exact Test for Count Data\n# \n# data:  cm\n# p-value = 0.0005686\n# alternative hypothesis: true odds ratio is not equal to 1\n# 95 percent confidence interval:\n#  1.577790 5.106564\n# sample estimates:\n# odds ratio \n#   2.953612\nchisq.test(cm, correct = FALSE)\n# \n#   Pearson's Chi-squared test\n# \n# data:  cm\n# X-squared = 16.587, df = 1, p-value = 4.647e-05\nz^2\n# [1] 16.58685\nlibrary(microbenchmark)\n\nmicrobenchmark(\n    hyper = 1 - phyper(13, 200, 38392, 968),\n    fisher = fisher.test(cm),\n    binom = 1 - pbinom(13, 968, 200/38592),\n    chisq = chisq.test(cm, correct = FALSE),\n    ztest = {\n        p1 = 14/200\n        p2 = 954/38392\n        p = 968/38592\n\n        z = abs(p1 - p2)/sqrt(p*(1-p))/sqrt(1/200 + 1/38392)\n        2*pnorm(z, lower.tail = FALSE)\n    },\n    times = 1000\n)\n# Unit: nanoseconds\n#    expr    min       lq       mean   median       uq     max neval\n#   hyper   1015   1339.0   1987.729   1976.0   2409.0   31312  1000\n#  fisher 550995 580583.5 662738.972 596404.5 635820.5 9415537  1000\n#   binom    888   1235.0   1983.052   1968.5   2542.0   21521  1000\n#   chisq  40779  49720.5  71201.448  58536.0  61390.5 7534850  1000\n#   ztest   1984   2635.0   3997.278   4182.0   4830.5   23940  1000\nora = function(genes, gene_sets, universe) {\n\n}"},{"path":"over-representation-analysis.html","id":"current-tools","chapter":"4 Over-Representation Analysis","heading":"4.5 Current tools","text":"many tools implement ORA analysis compared gene set enrichment analysis tools \nintroduced later chapters, mainly runs fast, method simply understand. ORA\nweb-based tools two-step analysis. 1. upload gene lists setting parameters 2. see results.\nsection, go three web-based ORA tools, well one Bioconductor package.need make sure gene IDs Entrez IDs. following function\nhelps automatically convert gene IDs Entrez IDs. input can vector\ngenes gene expression matrix.convert diff genes diff_gene Entrez IDs. Note genes lost\ndue conversion.Next perform ORA different gene setsGO enrichmentKEGG enrichmentReactome enrichmentDO enrichmentMSigDB enrichmentThere built-function specific MSigDB gene sets, universal function enrichr() accepts\nmanually-specified gene sets. gene sets object simply two-column data frame:first column gene set IDthe second column gene ID","code":"\nload(\"data/demo_ora.RData\")\nlibrary(clusterProfiler)\nhead(diff_gene)\n# [1] \"FGR\"    \"NIPAL3\" \"LAP3\"   \"CASP10\"\ndiff_gene = convert_to_entrez_id(diff_gene)\n# testing org.Hs.egENSEMBL...\n# testing org.Hs.egREFSEQ...\n# testing org.Hs.egSYMBOL...\n#   gene id might be SYMBOL (p = 1.000)\nhead(diff_gene)\n# [1] \"2268\"  \"57185\" \"51056\" \"843\"\nlength(diff_gene)\n# [1] 963\nlibrary(org.Hs.eg.db)\ntb = enrichGO(gene = diff_gene, ont = \"BP\", OrgDb = org.Hs.eg.db)\nhead(tb)\n#                    ID                   Description GeneRatio   BgRatio\n# GO:0006959 GO:0006959       humoral immune response    70/849 317/18800\n# GO:0002443 GO:0002443   leukocyte mediated immunity    80/849 457/18800\n# GO:0002253 GO:0002253 activation of immune response    73/849 386/18800\n# GO:0006909 GO:0006909                  phagocytosis    65/849 310/18800\n#                  pvalue     p.adjust       qvalue\n# GO:0006959 3.286195e-29 1.664786e-25 1.327969e-25\n# GO:0002443 4.867621e-26 9.919090e-23 7.912271e-23\n# GO:0002253 5.873918e-26 9.919090e-23 7.912271e-23\n# GO:0006909 7.862052e-26 9.957289e-23 7.942741e-23\n#                                                                                      geneID\n# GO:0006959 6556/729/2920/2219/4069/54209/730249/6347/3458/5967/729230/722/725/5266/6590/5..\n# GO:0002443 2268/4843/7305/57823/729/50943/7037/3383/54209/50487/51311/10312/57379/10384/8..\n# GO:0002253 2268/7305/11119/729/50943/2219/58484/54209/3055/80381/10384/2633/8013/722/725/..\n# GO:0006909 2268/23221/7305/6556/2219/54209/10326/3055/1089/6347/3458/4688/729230/722/725/..\n#            Count\n# GO:0006959    70\n# GO:0002443    80\n# GO:0002253    73\n# GO:0006909    65\ntb = enrichKEGG(gene = diff_gene, organism = \"hsa\")\nhead(tb)\n#                ID                                                   Description\n# hsa04060 hsa04060                        Cytokine-cytokine receptor interaction\n# hsa04061 hsa04061 Viral protein interaction with cytokine and cytokine receptor\n# hsa04657 hsa04657                                       IL-17 signaling pathway\n# hsa04380 hsa04380                                    Osteoclast differentiation\n#          GeneRatio  BgRatio       pvalue     p.adjust       qvalue\n# hsa04060    50/444 295/8192 2.388796e-13 7.357492e-11 6.412032e-11\n# hsa04061    27/444 100/8192 1.462161e-12 2.251729e-10 1.962375e-10\n# hsa04657    25/444  94/8192 1.450237e-11 1.488910e-09 1.297581e-09\n# hsa04380    29/444 128/8192 2.503473e-11 1.927674e-09 1.679962e-09\n#                                                                                    geneID\n# hsa04060 53832/608/2920/3595/3589/5008/1440/6354/6347/55801/3458/3552/7850/9173/8809/88..\n# hsa04061 53832/2920/6354/6347/8809/8807/729230/6372/51554/3569/4283/56477/3577/2921/637..\n# hsa04657 5743/2920/1440/6354/6347/3458/727897/6372/3553/2354/3569/4322/6279/3934/4314/6..\n# hsa04380 7305/54209/10326/54/11024/3458/3552/6772/2274/4688/8503/3553/2354/10288/7006/2..\n#          Count\n# hsa04060    50\n# hsa04061    27\n# hsa04657    25\n# hsa04380    29\nlibrary(ReactomePA)\ntb = enrichPathway(gene = diff_gene)\nhead(tb)\n#                          ID                         Description GeneRatio\n# R-HSA-6798695 R-HSA-6798695            Neutrophil degranulation    72/591\n# R-HSA-6783783 R-HSA-6783783            Interleukin-10 signaling    21/591\n# R-HSA-380108   R-HSA-380108 Chemokine receptors bind chemokines    22/591\n# R-HSA-449147   R-HSA-449147           Signaling by Interleukins    64/591\n#                 BgRatio       pvalue     p.adjust       qvalue\n# R-HSA-6798695 482/10891 1.650320e-15 1.823604e-12 1.735442e-12\n# R-HSA-6783783  47/10891 6.254910e-15 3.455838e-12 3.288766e-12\n# R-HSA-380108   59/10891 1.330760e-13 4.901632e-11 4.664664e-11\n# R-HSA-449147  473/10891 6.856512e-12 1.894111e-09 1.802541e-09\n#                                                                                         geneID\n# R-HSA-6798695 2268/64386/5329/7305/55/6556/2219/4680/4069/5836/10326/10562/3614/10493/10312/..\n# R-HSA-6783783 5743/2920/3383/7076/1440/6347/942/3552/7850/729230/3553/3569/3557/2919/3627/57..\n# R-HSA-380108  2920/6354/6347/729230/6372/51554/4283/56477/58191/3577/2921/6374/5196/2919/362..\n# R-HSA-449147  4843/53832/3082/6196/5743/2920/3595/3383/3589/5008/3055/7076/1440/6347/595/558..\n#               Count\n# R-HSA-6798695    72\n# R-HSA-6783783    21\n# R-HSA-380108     22\n# R-HSA-449147     64\nlibrary(DOSE)\ntb = enrichDO(gene = diff_gene, ont = \"DO\")\nhead(tb)\n#                  ID         Description GeneRatio  BgRatio       pvalue\n# DOID:403   DOID:403       mouth disease    52/504 188/8007 9.623979e-21\n# DOID:3388 DOID:3388 periodontal disease    44/504 139/8007 3.169110e-20\n# DOID:1091 DOID:1091       tooth disease    47/504 162/8007 8.987014e-20\n# DOID:850   DOID:850        lung disease    85/504 499/8007 3.419382e-18\n#               p.adjust       qvalue\n# DOID:403  7.574072e-18 3.717895e-18\n# DOID:3388 1.247045e-17 6.121386e-18\n# DOID:1091 2.357593e-17 1.157275e-17\n# DOID:850  6.727633e-16 3.302403e-16\n#                                                                                     geneID\n# DOID:403  4843/6401/3082/50943/5743/3595/5243/4069/3589/5008/7076/4210/5054/9126/6354/63..\n# DOID:3388 4843/6401/3082/50943/5743/3595/5243/4069/3589/5008/7076/5054/9126/6354/6347/34..\n# DOID:1091 4843/6401/3082/50943/5743/3595/5243/4069/3589/5008/7076/5054/9126/6354/6347/54..\n# DOID:850  4843/5329/6556/3082/50943/5743/3383/3589/3055/5054/6347/374/595/7450/59341/345..\n#           Count\n# DOID:403     52\n# DOID:3388    44\n# DOID:1091    47\n# DOID:850     85\nlibrary(msigdbr)\ngene_sets = msigdbr(category = \"H\")\nmap = gene_sets[, c(\"gs_name\", \"entrez_gene\")]\n\ntb = enricher(gene = diff_gene, TERM2GENE = map)\nhead(tb)\n#                                                                    ID\n# HALLMARK_INTERFERON_GAMMA_RESPONSE HALLMARK_INTERFERON_GAMMA_RESPONSE\n# HALLMARK_INFLAMMATORY_RESPONSE         HALLMARK_INFLAMMATORY_RESPONSE\n# HALLMARK_INTERFERON_ALPHA_RESPONSE HALLMARK_INTERFERON_ALPHA_RESPONSE\n# HALLMARK_TNFA_SIGNALING_VIA_NFKB     HALLMARK_TNFA_SIGNALING_VIA_NFKB\n#                                                           Description GeneRatio\n# HALLMARK_INTERFERON_GAMMA_RESPONSE HALLMARK_INTERFERON_GAMMA_RESPONSE    55/348\n# HALLMARK_INFLAMMATORY_RESPONSE         HALLMARK_INFLAMMATORY_RESPONSE    54/348\n# HALLMARK_INTERFERON_ALPHA_RESPONSE HALLMARK_INTERFERON_ALPHA_RESPONSE    33/348\n# HALLMARK_TNFA_SIGNALING_VIA_NFKB     HALLMARK_TNFA_SIGNALING_VIA_NFKB    49/348\n#                                     BgRatio       pvalue     p.adjust\n# HALLMARK_INTERFERON_GAMMA_RESPONSE 200/4383 1.471098e-17 6.914161e-16\n# HALLMARK_INFLAMMATORY_RESPONSE     200/4383 7.383369e-17 1.735092e-15\n# HALLMARK_INTERFERON_ALPHA_RESPONSE  97/4383 9.355985e-14 1.465771e-12\n# HALLMARK_TNFA_SIGNALING_VIA_NFKB   200/4383 1.524722e-13 1.791549e-12\n#                                          qvalue\n# HALLMARK_INTERFERON_GAMMA_RESPONSE 5.264982e-16\n# HALLMARK_INFLAMMATORY_RESPONSE     1.321234e-15\n# HALLMARK_INTERFERON_ALPHA_RESPONSE 1.116153e-12\n# HALLMARK_TNFA_SIGNALING_VIA_NFKB   1.364225e-12\n#                                                                                                              geneID\n# HALLMARK_INTERFERON_GAMMA_RESPONSE 51056/57823/10797/3430/5743/3383/10135/6354/6347/6648/942/6772/29126/7130/8103..\n# HALLMARK_INFLAMMATORY_RESPONSE     6401/5329/2769/490/3383/5008/7076/4210/366/3249/6324/10135/3696/5054/1440/6354..\n# HALLMARK_INTERFERON_ALPHA_RESPONSE 51056/3430/135112/3659/6737/94240/8638/10906/2766/834/10561/83666/7453/10410/8..\n# HALLMARK_TNFA_SIGNALING_VIA_NFKB   5329/490/5743/2920/3383/10135/5054/6347/374/595/6648/1839/3552/5341/8013/1958/..\n#                                    Count\n# HALLMARK_INTERFERON_GAMMA_RESPONSE    55\n# HALLMARK_INFLAMMATORY_RESPONSE        54\n# HALLMARK_INTERFERON_ALPHA_RESPONSE    33\n# HALLMARK_TNFA_SIGNALING_VIA_NFKB      49"},{"path":"over-representation-analysis.html","id":"limitations-of-ora","chapter":"4 Over-Representation Analysis","heading":"4.6 Limitations of ORA","text":"ORA analysis simply runs fast. Thus, currently, many online tools support . However, many limiations.","code":""},{"path":"over-representation-analysis.html","id":"different-tools-generate-inconsistent-results","chapter":"4 Over-Representation Analysis","heading":"4.6.1 different tools generate inconsistent results","text":"lot tools, using gene set database, results tools\nnormally agree well. reasons :Different versions annotation databases.process redundant termsDifferent default cutoffsDifferent methodd control p-valuesdiffernet background genes.","code":""},{"path":"over-representation-analysis.html","id":"sensitive-to-the-selection-of-background-genes.","chapter":"4 Over-Representation Analysis","heading":"4.6.2 sensitive to the selection of background genes.","text":"Genome / protein-coding gene / genes measured?\nselection mainly affects value blue cells.\nNote ORA actually compares diff gene set ‘gene,’ actually assume ‘genes’ diff set, thus, “genes” useless.\nSelect “large” background may increase false positives.\nSelect “small” background may miss positives, low false positives.\nAlso arguments: genes measured, put analysis.general, larger background set, p-value becomes significant. ORA","code":"\n1 - phyper(13, 200, 38392, 968)\n# [1] 0.0005686084\n1 - phyper(13, 200, 38392 - 10000, 968)\n# [1] 0.008444096\n1 - phyper(13, 200, 38392 - 20000, 968)\n# [1] 0.1606062\n1 - phyper(13, 200, 38392 + 10000, 968)\n# [1] 5.473547e-05\n1 - phyper(13, 200, 38392 + 20000, 968)\n# [1] 7.140953e-06"},{"path":"over-representation-analysis.html","id":"preference-of-larger-gene-sets","chapter":"4 Over-Representation Analysis","heading":"4.6.3 Preference of larger gene sets","text":"trend large gene sets may significant p-values.\nactually expected sample size increases, test power also increases. context hypergeometric test Binomial test, number genes “sample size.”","code":"\n1 - pbinom(52, 100, 0.5)\n# [1] 0.3086497\n1 - pbinom(52, 1000, 0.5)\n# [1] 1\n1 - pbinom(52, 10000, 0.5)\n# [1] 1\ntb = read.table(\"data/david_result.txt\", sep = \"\\t\", header = TRUE)\nplot(tb$Pop.Hits, -log10(tb$PValue), xlab = \"Gene set size\", ylab = \"-log10(p-value)\")"},{"path":"over-representation-analysis.html","id":"imbalanced-contigency-table","chapter":"4 Over-Representation Analysis","heading":"4.6.4 Imbalanced contigency table","text":"real-world scenario, show xx. many gene sets small number genes,\nmakes 2x2 contigency imbalanced.many cases gene set small, enrichment anlaysis sensitive value number \nDE genes gene set, .e., valeu \\(n_{11}\\).DE analysis, normally set cutoff adjusted p-values filter significant DE genes, since\np-values sensitive \\(n_{11}\\), actually xxx","code":"\nlibrary(grid)\ngrid.newpage()\npushViewport(viewport(x = 0, width = 0.5, just = \"left\"))\npushViewport(viewport(xscale = c(-1.5, 1.5), yscale = c(-1.5, 1.5), width = 0.9, height = 0.9))\ngrid.rect()\ngrid.circle(x = -0.4, y = 0, r = 1, default.units = \"native\")\ngrid.circle(x = 0.4, y = 0, r = 1, default.units = \"native\")\ngrid.text(\"gene set\", x = -0.5, y = -1.1, just = \"top\", default.units = \"native\")\ngrid.text(\"DE genes\", x = 0.5, y = -1.1, just = \"top\", default.units = \"native\")\ngrid.text(\"Theretical\", x = -1.4, y = 1.4, default.units = \"native\", just = c(\"left\", \"top\"))\npopViewport()\npopViewport()\n\npushViewport(viewport(x = 0.5, width = 0.5, just = \"left\"))\npushViewport(viewport(xscale = c(-1.5, 1.5), yscale = c(-1.5, 1.5), width = 0.9, height = 0.9))\ngrid.rect()\ngrid.circle(x = -0.75, y = 0, r = 0.3, default.units = \"native\")\ngrid.circle(x = 0.3, y = 0, r = 1.2, default.units = \"native\")\ngrid.text(\"gene set\", x = -0.8, y = -1.1, just = \"top\", default.units = \"native\")\ngrid.text(\"DE genes\", x = 0.9, y = -1.1, just = \"top\", default.units = \"native\")\ngrid.text(\"Real-world\", x = -1.4, y = 1.4, default.units = \"native\", just = c(\"left\", \"top\"))\npopViewport()\npopViewport()\n1 - phyper(13, 200, 38392, 968)\n# [1] 0.0005686084\n1 - phyper(13 - 3, 200, 38392, 968)\n# [1] 0.01263274\n1 - phyper(13 + 3, 200, 38392, 968)\n# [1] 1.35041e-05"},{"path":"over-representation-analysis.html","id":"theoretical-reasons","chapter":"4 Over-Representation Analysis","heading":"4.6.5 Theoretical reasons","text":"assumption","code":""},{"path":"the-gsea-method.html","id":"the-gsea-method","chapter":"5 The GSEA method","heading":"5 The GSEA method","text":"","code":""},{"path":"the-gsea-method.html","id":"overview-2","chapter":"5 The GSEA method","heading":"5.1 Overview","text":"tool GSEA mostly used gene set enrichment analysis. study, genes moderate change,\nfilter p-values DE anlaysis, signficant genes left. Thus ORA anlaysis applied .\nMootha developed new method takes genes consideration test teh significance gene sets evaluating \naccumulated effect genes’ diffenetial expression. successfully xxx . chapter xxx","code":""},{"path":"the-gsea-method.html","id":"the-gsea-method-version-one","chapter":"5 The GSEA method","heading":"5.2 The GSEA method, version one","text":"ORA analysis actually applies binary conversion genes genes pass cutoff set 1 others set 0. \nbinary transformation -simplifies problem lot information lost, e.g. differential expression, \ngenes around cutoff can optionally set 1 0 object choise cutoffs.GSEA method first proposed 2003. Authors worked dataset genes intermediate expression change,\nnormal differential gene expression methods, significant gene left normal cutoffs, thus\nORA analysis impossible perform. Mootha developed new method named GSEA convert genes rank differential\nexpression. Compared ORA, GSEA v1 can distingush differnet expression changes.","code":"ORA, differenital expression -> 1111100000\nGSEA   -> 1 2 3 4 5 6 ..."},{"path":"the-gsea-method.html","id":"gsea-v1-step-1","chapter":"5 The GSEA method","heading":"5.3 GSEA v1, step 1","text":"make simply discuss, assume expression data two-condition comparison, e.g. tumor vs normal treatment vs control.\nassume repeated samples conditions. first step GSEA reduce original matrix gene-level scores,, .e. row m1+m2 values,\nreduce single value measures differnetial expression conditions. GSEA, proposed use signial noise ratio (\\((\\mu_1 - \\mu_2)/(\\sigma_1 + \\sigma_2)\\)\nactually taken account sample size. However, larger S2N absolute value, differential gene expressed.obtaining gene-level score, rank transformation applied applied gene-level scores. genes sorted highest\nlowest form sorted gene list.","code":""},{"path":"the-gsea-method.html","id":"gsae-v1-step-2","chapter":"5 The GSEA method","heading":"5.4 GSAE v1, step 2","text":"sorted gene list, specific gene set, enrichment score can calculated. genes ranked list put two groups, gene set\ngene set. Denote total \\(n\\) genes, \\(n_k\\) number genes gene set \\(p\\) certain position ranked list. \ngenes gene set, calcualte fraction denoted \\(F_{1p}\\) position \\(p\\):\\[ F_{1p} = \\frac{1}{n_k}\\sum_{=1}^p (g_i \\G) \\]\\(()\\) identify function, \\(g_i\\) gene position \\(\\) \\(G\\) set genes gene set. Similarly, genes gene set, calculate second fraction denoted \\(F_{2p}\\)\nposition \\(p\\):\\[ F_{2p} = \\frac{1}{n - n_k}\\sum_{=1}^p (g_i \\notin G) \\]can seen, \\(F_{1p}\\) \\(F_{2p}\\) actually cummulative probability genes two sets. position \\(p\\), difference two cummulative probalibyy \ncalculated, maximal difference defined enrichmetn score (ES):\\[ ES = max_{p \\{1..n}} (F_{1p} - F{2p}) \\]According definition, actaully ES exactly teh Kolmogorov-Smirnov statistic use test whether two CDFs . Till now, since ES statistic\nknown sources, p-value can directly KS test. However, KS test powerful test orignal paper, also demonstrated later,\nnull hypothesis constructed via permuation-based test.According definition, ES actaully directional, always non-negative. ES score large, gene sets enriched top ranked gene list, shows higher expression group 1, assume positive different means high expression group 1. obtain -regulation, denifition ES can changed little bit:\\[ ES_{} = min_{p \\{1..n}} (F_{1p} - F{2p}) \\]case, \\(ES_{}\\) non-positive larger absolute value mean s…capture two directional change,\\[ k = argmax_p(|F_{1p} - F_{2p}|) \\]\n\\[ ES_{bidirectional} = |F_{1k} - F_{2k}| \\]","code":""},{"path":"the-gsea-method.html","id":"permutation-based-test","chapter":"5 The GSEA method","heading":"5.5 Permutation-based test","text":"definition ES statistic measures differential expression genes gene set, need null hypothesis distribution ES calculate p-values.\nKS-test can directly used calcualte p-values, GSEA uses robust way construct null distribution ES sample permutation.two-contidional data, genes gene set differneital expressed conditions, can say gene expression relates condition. randomly case, \ngene expression independent conditions observed value want reject null hypothesis. Since input matris normally complex, unlike \nt-test can anatical form normality assumption, obtain analytical form ES difficult. However, destroy relation gene expression\nconditions, simple power way random sample sample labels condition labels. fixed matrix, random assign xx group 1 \nsamle group 2. rando setting, actally means gene expression relation condition conditions randomly assigned. permuation \nrandom assignment process randomly shuffle xxx labels, keeps number samples two groups unchanged.sample permutation can simply done sample() function. Assume condition desigh 10 samples 5 group 5 group B:sample permutation generates new experimental design condition independent gene expression, thus ES can calculated step 1 2. teh sample permutation\nexeculted large number times gain enough “random” ES form null distribution. number permulations normally large recommended less 1000. null distribution ES random ES scores p-value defined probability ES euqla larger observed one:p-value can easily calculated :\\[ p = \\frac{1}{K}\\sum (ES_r \\geq ES) \\]Sample permutation powerful general way statistics. Chapter xx, demonstrate used construct non-parametric null distribution kind gene set level statistics. Also Chapter x, also introduce permuation data genes.","code":"\ncmp = rep(c(\"A\", \"B\"), each = 5)\nsample(cmp, length(cmp))\n#  [1] \"B\" \"A\" \"B\" \"A\" \"A\" \"B\" \"B\" \"B\" \"A\" \"A\""},{"path":"the-gsea-method.html","id":"the-gsea-method-version-2","chapter":"5 The GSEA method","heading":"5.6 The GSEA method, version 2","text":"first version GSEA successfully discovered affected biological functions show moderate expression chagnes. However, study, reseachers pointed\nseveral limitations algorithm. main argument GSEA algorithm, although can distinguish different levels differential expression,\ngenes equal distance neighbouring genes ranked list, following two consiquences:genes higher differnetial expression importantgenes middle hte gene list normally small change even change. However, assumulation middle can also cause enrichment.Due gene-level score uniform distribution xxx, 2005, Subrammian imporved GSEA algorithm taking gene-level score weight,\ncase, differential genes enhanced genes weak differneital expression suppressed. forms current standard GSEA algorithm.Recall define \\(F_{1p}\\) \\(F_{2p}\\). new GSEA changes definition \\(F_{1p}\\) :\\[ F_{1p} = \\frac{1}{n_r}\\sum_{=1}^p (g_i \\G) \\cdot |r_j|^\\]\n\\[ n_r = \\sum_{=1}^n (g_i \\G) \\cdot |r_j|^\\]Note \\(F_{2p}\\) genes genes unchanged. power \\(\\) reflects importance differential expression. default, GSEA set \\(= 1\\). \n\\(= 0\\), reduces original version GSEA.Similarlly ES score origial version, one-directional two-directinoal.Now form ES changed, thus, becomes -called “weighted KS statistics.” difficult perform test. , perform sample-permutation\nevery permutations, new ES score calclated .","code":""},{"path":"the-gsea-method.html","id":"compare-the-two-gsea","chapter":"5 The GSEA method","heading":"5.7 Compare the two GSEA","text":"interesting compare two versions GSEA see weight helps xxx also power test.","code":""},{"path":"the-gsea-method.html","id":"permutations","chapter":"5 The GSEA method","heading":"5.8 Permutations","text":"construct null distribution, introduced randonly suffle samples break relation xxx. actually second way construct “random dataset”\ngene permutation, randomly shuffle genes identially, randoly shuffle whether genes gene set . way break relation differnetial expression\nxx genes gene sets. assume genes differneitally expressed, randomized gene sets mostly show differneital expression.\nsample permutation, gene-level scores need calculated every permutatin, comparison, gene permutation, gene-level scores can \ncalculated can repeated used. current tools implements GSEA algorithm, teh null distribution generated gene permutation. Without\ngoing deep, wold like mention, two permutation methods, although produce ramdom dataset, correspond two complete different things. \nspecific datasets, two xxx may give complete different p-values (conclusions)","code":""},{"path":"the-gsea-method.html","id":"other-aspects-of-gsea","chapter":"5 The GSEA method","heading":"5.9 Other aspects of GSEA","text":"","code":""},{"path":"the-gsea-method.html","id":"the-direction-of-gsea","chapter":"5 The GSEA method","heading":"5.9.1 The direction of GSEA","text":"","code":""},{"path":"the-gsea-method.html","id":"leading-edge-genes","chapter":"5 The GSEA method","heading":"5.9.2 Leading edge genes","text":"","code":""},{"path":"the-gsea-method.html","id":"normalized-enrichment-score","chapter":"5 The GSEA method","heading":"5.9.3 Normalized enrichment score","text":"teh enrichment score averaged genes gene set, general, large significant gene sets may small ES scores. Thus, ES reflect\ndegree enrichment compariable gene sets. normalized","code":""},{"path":"the-gsea-method.html","id":"compare-ora-and-gsea","chapter":"5 The GSEA method","heading":"5.10 Compare ORA and GSEA","text":"Since ORA GSEA mostly used methods gene set enrichmetn anlaysis, interesting apply two methods dataset compare xxxPrepare data. read three types data:phenotype/condition datathe gene expression matrixthe gene setThe gene expression data saved .gct format experimental condition/phenotype\nsaves .cls format. formats simple, can try write \ncode parse .Gene sets saved \".gmt format. also simple format. can try parse\n.exprconditiongenesetThis gene set small:Note gene IDs expression matrix gene sets gene\nsymbols, thus adjustment needs done .gene-level difference score set signal--noise ratios, :mean group 1mean group 2sd group 1sd group 2\\[ \\frac{\\mu_1 - \\mu_2}{\\sigma_1 + \\sigma_2} \\]calculate gene-level difference score s:s: gene-level difference scoreSort gene scores highest lowest (make ranked list):Next first implement original GSEA method, proposed Mootha et al., 2003.f1 cumulative probability function genes set f2 cumulative probability function genes set.first plot CDF two distributions.reason blue locates almost diagonal gene set small.Next difference cumulative probability (f1 - f2) position ranked gene list.\nLet’s call “GSEA plot.”enrichment score (ES) defined max(f1 - f2) :position “GSEA plot”:statistic es actually Kolmogorov-Smirnov statistics, thus, can\ndirectly apply KS test:However, can see p-value significant, KS test \npowerful test. Next construct null distribution sample permutation.next code chunk, calculation ES score wrapped function,\nalso use rowMeans() rowSds() speed calculation gene-level\nscores.ES score calculated calculate_es():randomly permute sample labels randomly permute condition. \n1000 times. ES scores null distributions saved es_rand.p-value calculated proportion es equal larger values es_rand.0.129The null distribution ES:Next implement improved GSEA (Subramanian et al., PNAS, 2005) gene-level scores taken weight.directly modify calculate_es() calculate_es_v2() two lines new, highlight code chunk:Now calculate new ES score make GSEA plot:can also check power = 0 power = 2:Similarly, randomly permute samples obtain null distribution ES:new p-value:1/1000, < 0.001And null distribution ES:can see improved GSEA powerful original GSEA, \noriginal GSEA equally weights genes improved GSEA weights genes based differential expression,\nincreases effect diff genes. Let’s plot weight genes:Null distribution can also constructed gene permutation. \neasy implement:Good thing gene permutation gene-level scores need calculated\ncan repeatedly used.calculate null distribution ES gene permutation:also < 0.001The null distribution ES gene permutation:","code":"\nx = 1:40\ngs = c(F, T, T, T, F, F, T, T, T, T, F, T, T, T, F, F, F, F, F, F, F, F, F, T, F, F, F, F, F, F, F, T, F, F, F, F, F, F, F, F)\n\n\ngsea_cdf = function(x, gs, ...) {\n    f1 = cumsum(gs)/sum(gs)\n\n    f2 = cumsum(!gs)/sum(!gs)\n\n    n = length(x)\n    plot(1:n, f1, type = \"s\", col = 2, ylim = c(0, 1.1),\n        xlab = \"Ranked gene list\", ylab = \"Cumulative probability P_n(X >= x)\", ...)\n    lines(1:n, f2, type = \"s\", col = 4)\n\n    segments(1:n, 1.05, 1:n, 1.1, col = ifelse(gs, 2, 4))\n}\n\ngsea_cdf(x, gs)\n\ngs = c(rep(T, 10), rep(F, 30))\ngsea_cdf(x, gs)\n\ngs = c(rep(F, 30), rep(T, 10))\ngsea_cdf(x, gs)\n\ngs = sample(c(T, F), 40, replace = TRUE)\ngsea_cdf(x, gs)\nset.seed(54)\nmean_diff1 = rnorm(20)\n\nm1 = do.call(rbind, lapply(1:20, function(i) {\n    c(rnorm(10, mean = mean_diff1[i]), rnorm(10, mean = -mean_diff1[i]))\n}))\nrownames(m1) = paste0(\"g\", 1:20)\n\nx1 = rowMeans(m1)\n\nx2 = sort(x1, decreasing = TRUE)\n\nfa = c(rep(\"Group1\", 10), rep(\"Group2\", 10))\nlibrary(ComplexHeatmap)\nht_list = Heatmap(m1, top_annotation = HeatmapAnnotation(group = fa), cluster_rows = FALSE, cluster_columns = FALSE) +\n    Heatmap(x1, col = c(\"orange\", \"white\", \"purple\"), left_annotation = rowAnnotation(pt1 = anno_points(x1, width = unit(2, \"cm\")))) +\n    Heatmap(x2, col = c(\"orange\", \"white\", \"purple\"), left_annotation = rowAnnotation(pt2 = anno_points(x2, width = unit(2, \"cm\"))))\n\ndraw(ht_list, ht_gap = unit(4, \"cm\"), auto_adjust = FALSE)\nlibrary(CePa)\ncondition = read.cls(\"data/P53.cls\", treatment = \"MUT\", control = \"WT\")$label\nexpr = read.gct(\"data/P53_collapsed_symbols.gct\")\n\nln = strsplit(readLines(\"data/c2.symbols.gmt\"), \"\\t\")\ngs = lapply(ln, function(x) x[-(1:2)])\nnames(gs) = sapply(ln, function(x) x[1])\n\ngeneset = gs[[\"p53hypoxiaPathway\"]]\nlength(geneset)\n# [1] 20\ns = apply(expr, 1, function(x) {\n    x1 = x[condition == \"WT\"]\n    x2 = x[condition == \"MUT\"]\n    (mean(x1) - mean(x2))/(sd(x1) + sd(x2))\n})\ns = sort(s, decreasing = TRUE)\n## original GSEA\nl_set = names(s) %in% geneset\nf1 = cumsum(l_set)/sum(l_set)\n\nl_other = !names(s) %in% geneset\nf2 = cumsum(l_other)/sum(l_other)\nn = length(s)\nplot(1:n, f1, type = \"l\", col = \"red\")\nlines(1:n, f2, col = \"blue\")\nplot(f1 - f2, type = \"l\")\nabline(h = 0, lty = 2, col = \"grey\")\npoints(which(l_set), rep(0, sum(l_set)), pch = \"|\", col = \"red\")\nes = max(f1 - f2)\nes\n# [1] 0.2294643\nplot(f1 - f2, type = \"l\")\nabline(h = 0, lty = 2, col = \"grey\")\npoints(which(l_set), rep(0, sum(l_set)), pch = \"|\", col = \"red\")\nabline(v = which.max(f1 - f2), lty = 3, col = \"blue\")\nks.test(which(l_set), which(l_other))\n# \n#   Asymptotic two-sample Kolmogorov-Smirnov test\n# \n# data:  which(l_set) and which(l_other)\n# D = 0.22946, p-value = 0.244\n# alternative hypothesis: two-sided\nlibrary(matrixStats)\n# expr: the complete expression matrix\n# condition: the condition labels of samples\n# cmp: a vector of two, cmp[1] - cmp[2] > 0 means up-regulation\n# geneset: A vector of genes\ncalculate_es = function(expr, condition, cmp, geneset) {\n\n    m1 = expr[, condition == cmp[1]]  # only samples in group 1\n    m2 = expr[, condition == cmp[2]]  # only samples in group 2\n\n    s = (rowMeans(m1) - rowMeans(m2))/(rowSds(m1) + rowSds(m2)) # a gene-level difference socre (S2N ratio) \n\n    s = sort(s, decreasing = TRUE)  # ranked gene list\n\n    l_set = names(s) %in% geneset\n    f1 = cumsum(l_set)/sum(l_set)   # CDF for genes in the set\n\n    l_other = !l_set\n    f2 = cumsum(l_other)/sum(l_other)  # CDF for genes not in the set\n\n    max(f1 - f2)\n}\nes = calculate_es(expr, condition, cmp = c(\"WT\", \"MUT\"), geneset = geneset)\nes\n# [1] 0.2294643\nset.seed(123)\nes_rand = numeric(1000)\nfor(i in 1:1000) {\n    es_rand[i] = calculate_es(expr, sample(condition), \n        cmp = c(\"WT\", \"MUT\"), geneset = geneset)\n}\nsum(es_rand >= es)/1000\n# [1] 0.129\nhist(es_rand)\nabline(v = es, col = \"red\")\ncalculate_es_v2 = function(expr, condition, cmp, geneset, plot = FALSE, power = 1) {\n\n    m1 = expr[, condition == cmp[1]]\n    m2 = expr[, condition == cmp[2]]\n\n    s = (rowMeans(m1) - rowMeans(m2))/(rowSds(m1) + rowSds(m2))\n\n    s = sort(s, decreasing = TRUE)\n\n    l_set = names(s) %in% geneset\n    # f1 = cumsum(l_set)/sum(l_set)  # <<-- the original line\n    s_set = abs(s)^power   # <<-- here\n    s_set[!l_set] = 0\n    f1 = cumsum(s_set)/sum(s_set)  ## <<- here\n\n    l_other = !l_set\n    f2 = cumsum(l_other)/sum(l_other)\n\n    if(plot) {\n        plot(f1 - f2, type = \"l\")\n        abline(h = 0, lty = 2, col = \"grey\")\n        points(which(l_set), rep(0, sum(l_set)), pch = \"|\", col = \"red\")\n        abline(v = which.max(f1 - f2), lty = 3, col = \"blue\")\n    }\n\n    max(f1 - f2)\n}\nes = calculate_es_v2(expr, condition, cmp = c(\"WT\", \"MUT\"), plot = TRUE, \n    geneset = geneset)\npar(mfrow = c(1, 2))\ncalculate_es_v2(expr, condition, cmp = c(\"WT\", \"MUT\"), plot = TRUE, power = 0, \n    geneset = geneset)  # same as the original GSEA\n# [1] 0.2294643\ntitle(\"power = 0\")\ncalculate_es_v2(expr, condition, cmp = c(\"WT\", \"MUT\"), plot = TRUE, power = 2, \n    geneset = geneset)\n# [1] 0.8925371\ntitle(\"power = 2\")\npar(mfrow = c(1, 1))\nes_rand = numeric(1000)\nfor(i in 1:1000) {\n    es_rand[i] = calculate_es_v2(expr, sample(condition), \n        cmp = c(\"WT\", \"MUT\"), geneset = geneset)\n}\nsum(es_rand >= es)/1000\n# [1] 0\nhist(es_rand, xlim = c(0, 1))\nabline(v = es, col = \"red\")\nplot(abs(s))\n# s: a vector of pre-calcualted gene-level scores\n# s should be sorted\ncalculate_es_v2_gene_perm = function(s, perm = FALSE, power = 1) {\n    \n    if(perm) {\n        # s is still sorted, but the gene labels are randomly shuffled\n        names(s) = sample(names(s))  ## <<- here\n    }\n\n    l_set = names(s) %in% geneset\n    s_set = abs(s)^power\n    s_set[!l_set] = 0\n    f1 = cumsum(s_set)/sum(s_set)\n\n    l_other = !l_set\n    f2 = cumsum(l_other)/sum(l_other)\n\n    max(f1 - f2)\n}\n# pre-calculate gene-level scores\nm1 = expr[, condition == \"WT\"]\nm2 = expr[, condition == \"MUT\"]\n\ns = (rowMeans(m1) - rowMeans(m2))/(rowSds(m1) + rowSds(m2))\ns = sort(s, decreasing = TRUE)  # must be pre-sorted\nes = calculate_es_v2_gene_perm(s)\nes_rand = numeric(1000)\nfor(i in 1:1000) {\n    es_rand[i] = calculate_es_v2_gene_perm(s, perm = TRUE)\n}\n\nsum(es_rand >= es)/1000\n# [1] 0\nhist(es_rand, xlim = c(0, 1))\nabline(v = es, col = \"red\")"},{"path":"gsea-framework.html","id":"gsea-framework","chapter":"6 GSEA framework","heading":"6 GSEA framework","text":"","code":""},{"path":"gsea-framework.html","id":"overview-3","chapter":"6 GSEA framework","heading":"6.1 Overview","text":"Recall Chapter xx introduce GSEA algorithm, first step calcualte gene-level scores, gene-levels scores gene set aggregated\ngene set-level score testing. procedure can generalized general framework includes calculation gene level scores , gene set level scores\nconstructin null distributions. According set-level statistic designed, two main methologies: 1. univariate methods 2. multivariate methods.\nfirst one used current studies second one considered gene-gene correlation structures…seveal reivews xxx.","code":""},{"path":"gsea-framework.html","id":"the-univariate-methods","chapter":"6 GSEA framework","heading":"6.2 The univariate methods","text":"univariate methods two-step methods expression matrix first merged gene-level scores measures\ngene-level differential expression. Later gene set, member genes merged single statistic permutation\ntest applied construct null distribution.two steps, gene-gene correlation strucutre actually taken consideration, thus follows univriate procedure co-variants considered.","code":""},{"path":"gsea-framework.html","id":"gene-level-methods","chapter":"6 GSEA framework","heading":"6.2.1 Gene-level methods","text":"first step univarirate procedures calculate gene-level statistic, , make discussion simple, assume\ndata two-condition comparison. later demonstrate complicated experimental designs. Let’s denote \\(\\mathbf{x_1}\\)\nvector gene expression gene \\(\\) group 1, \\(\\mathbf{x_2}\\) vector gene expression gene \\(\\) group 2. \ngene-level transformation function \\(f()\\) applies \\(\\mathbf{x_1}\\) \\(\\mathbf{x_2}\\) togenerate single value:\\[ f(\\mathbf{x_1}, \\mathbf{x_1}) -> single value \\]variaty methods can used calculate gene-level scores. thing score measures degree differnetial expression,\nthus high absolute value score, differnetial gene expressed. Commonly used methods :t-value, defined \\(\\frac{}{}\\).log2 fold changesignal--noise ratioSAM regularized t-valuesIn xxx, lists gene-level statistics. However, authors demonstarted selection gene-level statistic less important GSEA. main reason\nmethod always applied two vectors without extra information, performs similar. still difference various methods.– scater plotMore generally, relation gene expression condition design can modeled via linear regression. linear regression, can deal \ncomplicated experimental designs, 1. conditions 2, 2. continouse conditions e.g. age dose treatment, 3. time series data, 4 multiple condition variates 5. allows full model vs reduced model test partial effect variate. univariet,\\[y = \\mu + \\beta x + \\epsilon \\]\\(x\\) condition variable, can categorical variable, continuous variable time series variable. multiple variates:\\[ y = \\mu + \\beta_1 x_1 + \\beta_2 x_2 + ... + \\epsilon \\]gene-level statistic can use regression coeffcient statistics measures goodness liear fitting. However, users need\ncareful complex models make results less explainable.","code":""},{"path":"gsea-framework.html","id":"transformation-of-gene-level-statistics","chapter":"6 GSEA framework","heading":"6.2.2 Transformation of gene-level statistics","text":"step optional can merged previous step. obtaining vector gene-level scores, can apply proper transformation\n. transformation also function takes original gene-level scores outputs new gene-level scores. followng\nfour widel y used transformationsabsolutesquare powerbinaryrankThe absolute square transformation helps capture bi-directional changes square transformation can addtionally increase weight\ndifferetiaally expressed genes. Binary transformation corresponds ORA analysis rank transformaton used GSEA.Please note, till now haven’t used information gene sets. calculation gene-level statistics independen gene sets. just processing\noriginal matrix, words, transformation original \\(n x m\\) matrix \\(n\\) vector. next step, genes gene sets\nextracted gene-level vectors calcualte gene set level statistic.","code":""},{"path":"gsea-framework.html","id":"set-level-methods","chapter":"6 GSEA framework","heading":"6.2.3 Set-level methods","text":"gene-level scores calculated already, can check whether genes gene sets general differnetial expressed. Regarding compare, ie. background,\nfollowing two scenarios:consider genes gene set, case, “background” genes differnetially expressed. function\ncalculating gene-set level scores, takes vector input, gene-level scores genes current gene set.COmpare genes gene set genes gene set. Now background genes. case, gene set level function takes two\nvectors input.two scenarions actaully measures different things, users need keep mide use corresponding methods.first case, gene set level statistic calcualted gene set, basically measures overall difference genes gene set.\naggregation gene-level statstis singl set0-level statistic. following widely used methods:Sum / MeanMedianMaxmeanNote genes gene set may also show bi-directional pattern, genes -regulated -regulated. Sum/Mean/Median good\nmeasure one-direcitonal change, bi-direcitional change wil cancled, thus get small value. problem can fixed first apply\nabsolute transformation gene-level scores.Maxmean method proposed xxx. basically takes max mean positive vlaues negative values.second scenario also compare genes gene set. Denote gene-level statistis genes set \\(r_1\\) \nset \\(r_0\\), teh set-level statistic measures difference \\(r_1\\) \\(r_0\\). following three methods:(weighted) KS statisticWilcoxon-rank statistic2x2 contigency tablewiht two vectors \\(r_1\\) \\(r_0\\), normally non-paremetric statistics used, methods assume normality, parametric test\nt-test can used. …2x2 contigen table ORA analysis actually also compare genes set genes set.works better differential expression genes set weak. However, data huge number genes differnetial expressed e.g. \ncancer vs normal. method may give wrong conclusions. e.g. gene set significant, reseachers may make conclusion\nbiological function gnee set significantly altered, actually xxxFinally, flexible design set-level statistic. one principle : higher value, differnetial genes gene set .","code":""},{"path":"gsea-framework.html","id":"current-tools-1","chapter":"6 GSEA framework","heading":"6.2.4 Current tools","text":"Many current tools follows univarate frameworks.","code":""},{"path":"gsea-framework.html","id":"implement-ora-under-univariate-framework","chapter":"6 GSEA framework","heading":"6.2.5 Implement ORA under univariate framework","text":"ORA can implemented teh univate framework. 2x2 contigency table, numer genes gene set \\(n_{11}\\) actually can \nused set-level statistic becuase higher \\(n_{11}\\), enriched xxx. translate univariate framework, :gene-level statistics: p-value/FDR differential expression testgene-level transformation: binary setting cutoff e.g. FDR < 0.05, 1, else 0)set-level statistics: sum, \\(n_{11}\\)Note \\(n_{11}\\) used genes gene set.also introduced using chi-square test 2x2 contigency table, Thus, Chi-suqare statistic can used teh set-level statistic. \ndiffernet fro first ORA translation, chi-square test acautally compares genes gene set gene set.third way , begnining introduce overpresentation, simply defined value fraction two ratios. value can also \nset-level statitic. Note statistics alsoused information genes set set.xxx, p-values calculatd probability larger equal observed values. set-level statists\none-directional change, see power -regulation. Users may need perform second aalyais looks tail hte null distribution.","code":""},{"path":"gsea-framework.html","id":"null-distribution-of-set-level-statistics","chapter":"6 GSEA framework","heading":"6.2.6 Null distribution of set-level statistics","text":"set-level statistic, need construct null distribution calculting p-values. depends methods,\nteh following three ways:exact distributionparametric distributionpermutation-based distributinohypergeometric distribution exact distribution ORA, however, normally impossbiel obtain exact distibutions. Also users recall\nhypergeometrix distribution strong conditions genes independenly differnetially expressed, may fit real cases.Parametrix distribution\nneeds assumptions distribution whihc normally normal distributions univaraite framework, xxx. used permuation-based distribution\nconstruct distribution directly data.","code":""},{"path":"gsea-framework.html","id":"permutation-based-distribution","chapter":"6 GSEA framework","heading":"6.2.7 Permutation-based distribution","text":"permutaion generates null distribution data, permuting origial data set destroy dependencies xx xx. non-parametrix\nassumption proir distribion. ALso three permutation methods:permute samplespermute genespermute dimensionsIn general, permutation powerful method generate null distribution calculate p-values. sinde distributionThe two permutations, although randomize data, actually correspond two different\nnull hypotheses:sample permutation, looks genes geneset null hypothesis :gene expression related condition settings.xxx, termed self-contained.gene permutation, compares genes gene set genes gene set. null hypotheses\n:differential gene expression gene set genes outside set.Users can imagien one horizontal comparison vertical comparison.two permutations widely used current tools, one advantages disadvanges.\nsample permutation, main advantages ae:gene-gene correlation keptTHe permutation clear real biological meaningTHe distadvantages areEach time, gene-level statistics need recalculatedmore sensitive, assume one genes set differnetially expressed, whole gene set\ncan assessed significant.gene permutation. advantage isthe gene-level statistics can repeated used. words, calculation \ngene-level scores can separated GSEA input can just gene-level score vector.disadvanges :permutaiton assumes independency genes gene-gene correlation gene set brokennull distribution clear biological meaningsIt may work better gene set small genes diffenritla expression thie whote dataset.interesting compare sample permutation gene permutation realworld data.\nP53 dataset used original GSEA paper two groups P53 wild type\nP53 mutant. take “P53 pathway” gene set\" expected significant.compare … assume \\(s\\) set-level score calclated real data \\(s_{null}\\) vector \nlength 1000 calculated permutation sample gene, compare different methods,\ncalculated relative value:\\[ \\frac{s - mean_null}{sd_null} \\]relative distance fro s center null distribution.general, sample permutation statistically pwoerful gene-permutation.","code":""},{"path":"gsea-framework.html","id":"the-multivariate-methods","chapter":"6 GSEA framework","heading":"6.3 The multivariate methods","text":"second framework multivariate methods takes matrix singl input\nreturns xx. basically consider co-variance data.Normally, multivaraite methods complex. use complicated statistic computations trying\netablish statsitcal framwork …globaltestGlobalANCOVAHotelling’ T2 testSince parametric nature, need assumptions, sometiThe basically idea multivariate methods follow either following two linear models:\\[ = bC + e \\]\n\\[ C = bA + e \\]\\(\\) \\(C\\) matrices. solve problem, can use pricinpal componet regression,\npartially lease square regression regulazeid linear regression.","code":""},{"path":"gsea-framework.html","id":"implementation-of-gsea-framework","chapter":"6 GSEA framework","heading":"6.4 Implementation of GSEA framework","text":"process (univariate) GSEA analysis:basically, calculation gene-level statistics set-level statistics can separated.implement three independent parts: \\(f()\\), \\(f'()\\) \\(g()\\).first implement function calculates gene-level statistics. make things simple, assume matrix two-condition comparison.input: expresion matrix (condition labels)input: expresion matrix (condition labels)output: vector gene-level scoresoutput: vector gene-level scoresmethod: (t-value, log2fc, …)method: (t-value, log2fc, …)transformation gene-level values can actually integrated part calculation gene-level values, .e. \\(f'(f())\\) can also thought\ngene-level statistic.gene-level stat p-values\nneed set cutoff p convert 1/0binarize()\ninput: origial gene-level stat (e.g. p-value)\nouput: values 1/0binarize = function(x) ifelse(x < 0.05, 1, 0)gene-level stat log2fcbinarize = function(x) ifelse(abs(x) > 1, 1, 0)Let’s test gene_level(). still use p53 dataset GSEA original paper.Let’s check gene-level values:Also can check number differential genes (gene level: ttest + transform: binary).\nNote better way filter FDR, simplicity, use p-values directly.method set log2fc, differential genes can selected setting cutoff log2 fold change.Implementing gene_level() actually simply.Next implement calculation set-level statistics. nature design set-level function let accept vector gene-level statistics gene set represented vector genes, like follows:However, need make sure genes geneset also gene_stat. safer way\ntest genes gene_stat also geneset:However, recall set-level can also calculated based genes outside gene set. Thus two arguments set_level() vector gene-level statistics genes logical vector shows whether genes current gene set. setting, can know genes set genes set.geneset vector gene IDs\nnow l_set: logical vector, length gene_stat,\nvalue TRUE, means gene set, FALSE, gene setLet’s check set_level():input set_level():gene-level scoresa logical vector shows whether genes setNow can wrap gene_level() set_level() single function gsea_tiny() accepts expression one gene set input,\nreturns set-level score.gsea_tiny():expression matrix (condition labels)gene setoutput: set-level statisticgsea_tiny() [ gene_level() + set_level() ]apply gsea_tiny() p53 dataset.use wilcox.test() calculate Wilcoxon statistic. Note function also lot extra calculations. can implement function “just” calculates Wilcoxon statistic nothing else:formula Wikipedia (https://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U_test).Note, make wilcox_stat() faster, use maximal 100 data points. \ndemonstration purpose, use real applications.“outer” calculationx, y\nevery value x every value yif length(x) n, length(y) mn*mouter()m = outer(x, y, “>”)Similarly, implement new function calculates chi-square statistic:change set_level() accordingly:Next adjust gsea_tiny() let work multiple gene sets support random permutation p-value calculation.let support list gene sets, simply change format geneset variable.","code":"\nlibrary(CePa)\ncondition = read.cls(\"data/P53.cls\", treatment = \"MUT\", control = \"WT\")$label\ncondition = factor(condition, levels = c(\"WT\", \"MUT\"))\n\nexpr = read.gct(\"data/P53_collapsed_symbols.gct\")\n# implement t-values as gene-level stat\ngene_level = function(mat, condition) {\n  \n  tdf = genefilter:rowttests(mat, factor(condition))\n  stat = tdf$statistic\n  return(stat)\n}\nlibrary(matrixStats)\nlibrary(genefilter)\n\n# -condition to be a factor\ngene_level = function(mat, condition, method = \"tvalue\") {\n        \n    le = levels(condition)\n    l_group1 = condition == le[1]\n    l_group2 = !l_group1\n    \n    mat1 = mat[, l_group1, drop = FALSE]  # sub-matrix for condition 1\n    mat2 = mat[, l_group2, drop = FALSE]  # sub-matrix for condition 2\n    \n    if(method == \"log2fc\") {\n        stat = log2(rowMeans(mat1)/rowMeans(mat2))\n    } else if(method == \"s2n\") {\n        stat = (rowMeans(mat1) - rowMeans(mat2))/(rowSds(mat1) + rowSds(mat2))\n    } else if(method == \"tvalue\") {\n        stat = (rowMeans(mat1) - rowMeans(mat2))/sqrt(rowVars(mat1)/ncol(mat1) + rowVars((mat2)/ncol(mat2)))\n    } else if(method == \"sam\") {\n        s = sqrt(rowVars(mat1)/ncol(mat1) + rowVars((mat2)/ncol(mat2)))\n        stat = (rowMeans(mat1) - rowMeans(mat2))/(s + quantile(s, 0.1))\n    } else if(method == \"ttest\") {\n        stat = rowttests(mat, factor(condition))$p.value\n    } else {\n        stop(\"method is not supported.\")\n    }\n    \n    return(stat)\n}\ns = gene_level(expr, condition, method = \"s2n\")\ngene_level = function(mat, condition, method = \"tvalue\", transform = \"none\", \n  binarize = function(x) x) {\n        \n    le = levels(condition)\n    l_group1 = condition == le[1]\n    l_group2 = !l_group1\n    \n    mat1 = mat[, l_group1, drop = FALSE]\n    mat2 = mat[, l_group2, drop = FALSE]\n    \n    if(method == \"log2fc\") {\n        stat = log2(rowMeans(mat1)/rowMeans(mat2))\n    } else if(method == \"s2n\") {\n        stat = (rowMeans(mat1) - rowMeans(mat2))/(rowSds(mat1) + rowSds(mat2))\n    } else if(method == \"tvalue\") {\n        stat = (rowMeans(mat1) - rowMeans(mat2))/sqrt(rowVars(mat1)/ncol(mat1) + rowVars((mat2)/ncol(mat2)))\n    } else if(method == \"sam\") {\n        s = sqrt(rowVars(mat1)/ncol(mat1) + rowVars((mat2)/ncol(mat2)))\n        stat = (rowMeans(mat1) - rowMeans(mat2))/(s + quantile(s, 0.1))\n    } else if(method == \"ttest\") {\n        stat = rowttests(mat, factor(condition))$p.value\n    } else {\n        stop(\"method is not supported.\")\n    }\n    \n    if(transform == \"none\") {\n        \n    } else if(transform == \"abs\") {\n        stat = abs(stat)\n    } else if(transform == \"square\") {\n        stat = stat^2\n    } else if(transform == \"binary\") {\n        stat = binarize(stat)\n    } else {\n        stop(\"method is not supported.\")\n    }\n    \n    return(stat)\n}\nmethods = c(\"log2fc\", \"s2n\", \"tvalue\", \"sam\")\nlt = lapply(methods, function(x) gene_level(expr, condition, method = x))\nnames(lt) = methods\npairs(lt)\ns = gene_level(expr, condition, method = \"ttest\", transform = \"binary\", \n    binarize = function(x) ifelse(x < 0.05, 1, 0))\ntable(s)\n# s\n#    0    1 \n# 9394  706\ns = gene_level(expr, condition, method = \"log2fc\", transform = \"binary\", \n    binarize = function(x) ifelse(abs(x) > 1, 1, 0))\ntable(s)\n# s\n#    0    1 \n# 9717  383\nset_fun = function(gene_stat, geneset) {\n    s = gene_stat[geneset]\n    mean(s)\n}\nset_fun = function(gene_stat, geneset) {\n    s = gene_stat[ names(gene_stat) %in% geneset ]\n    mean(s)\n}\nset_level = function(gene_stat, l_set, method = \"mean\") {\n    if(!any(l_set)) {\n        return(NA)\n    }\n    \n    if(method == \"mean\") {\n        stat = mean(gene_stat[l_set])\n    } else if(method == \"sum\") {\n        stat = sum(gene_stat[l_set])      \n    } else if(method == \"median\") {\n        stat = median(gene_stat[l_set])\n    } else if(method == \"maxmean\") {\n        s = gene_stat[l_set]\n        s1 = mean(s[s > 0]) # s1 is positive\n        s2 = mean(s[s < 0])  # s2 is negative\n        stat = ifelse(s1 > abs(s2), s1, s2)\n    } else if(method == \"ks\") {\n        # order gene_stat\n        od = order(gene_stat, decreasing = TRUE)\n        gene_stat = gene_stat[od]\n        l_set = l_set[od]\n        \n        s_set = abs(gene_stat)\n        s_set[!l_set] = 0\n        f1 = cumsum(s_set)/sum(s_set)\n    \n        l_other = !l_set\n        f2 = cumsum(l_other)/sum(l_other)\n    \n        stat = max(f1 - f2)\n    } else if(method == \"wilcox\") {\n        stat = wilcox.test(gene_stat[l_set], gene_stat[!l_set])$statistic\n    } else if(method == \"chisq\") {\n        # should on work with binary gene-level statistics\n        stat = chisq.test(factor(gene_stat), factor(as.numeric(l_set)))$statistic\n    } else {\n        stop(\"method is not supported.\")\n    }\n    \n    return(stat)\n}\ngene_stat = gene_level(expr, condition)\n\nln = strsplit(readLines(\"data/c2.symbols.gmt\"), \"\\t\")\ngs = lapply(ln, function(x) x[-(1:2)])\nnames(gs) = sapply(ln, function(x) x[1])\n\ngeneset = gs[[\"p53hypoxiaPathway\"]]\nl_set = rownames(expr) %in% geneset\nset_level(gene_stat, l_set)\n# [1] 0.8476668\nset_level(gene_stat, l_set, method = \"ks\")\n# [1] 0.6380268\ngsea_tiny = function(mat, condition, \n    gene_level_method = \"tvalue\", transform = \"none\", binarize = function(x) x,\n    set_level_method = \"mean\", geneset) {\n    \n    gene_stat = gene_level(mat, condition, method = gene_level_method, \n        transform = transform, binarize = binarize)\n    \n    l_set = rownames(mat) %in% geneset\n    \n    set_stat = set_level(gene_stat, l_set, method = set_level_method)\n    \n    return(set_stat)\n}\ngsea_tiny(expr, condition, geneset = geneset)\n# [1] 0.8476668\nwilcox_stat = function(x1, x2) {\n  if(length(x1) > 100) {\n    x1 = sample(x1, 100)\n  }\n  if(length(x2) > 100) {\n    x2 = sample(x2, 100)\n  }\n  sum(outer(x1, x2, \">\"))\n}\n# x1: a logical vector or a binary vector\n# x2: a logical vector or a binary vector\nchisq_stat = function(x1, x2) {\n    n11 = sum(x1 & x2)\n    n10 = sum(x1)\n    n20 = sum(!x1)\n    n01 = sum(x2)\n    n02 = sum(!x2)\n    n = length(x1)\n\n    n12 = n10 - n11\n    n21 = n01 - n11\n    n22 = n20 - n21\n\n    p10 = n10/n\n    p20 = n20/n\n    p01 = n01/n\n    p02 = n02/n\n\n    e11 = n*p10*p01\n    e12 = n*p10*p02\n    e21 = n*p20*p01\n    e22 = n*p20*p02\n\n    stat = (n11 - e11)^2/e11 +\n           (n12 - e12)^2/e12 +\n           (n21 - e21)^2/e21 +\n           (n22 - e22)^2/e22\n    return(stat)\n}\nset_level = function(gene_stat, l_set, method = \"mean\") {\n    if(!any(l_set)) {\n        return(NA)\n    }\n    \n    if(method == \"mean\") {\n        stat = mean(gene_stat[l_set])\n    } else if(method == \"sum\") {\n        stat = sum(gene_stat[l_set])      \n    } else if(method == \"median\") {\n        stat = median(gene_stat[l_set])\n    } else if(method == \"maxmean\") {\n        s = gene_stat[l_set]\n        s1 = mean(s[s > 0])\n        s2 = mean(s[s < 0])\n        stat = ifelse(s1 > abs(s2), s1, s2)\n    } else if(method == \"ks\") {\n        # order gene_stat\n        od = order(gene_stat, decreasing = TRUE)\n        gene_stat = gene_stat[od]\n        l_set = l_set[od]\n        \n        s_set = abs(gene_stat)\n        s_set[!l_set] = 0\n        f1 = cumsum(s_set)/sum(s_set)\n    \n        l_other = !l_set\n        f2 = cumsum(l_other)/sum(l_other)\n    \n        stat = max(f1 - f2)\n    } else if(method == \"wilcox\") {\n        stat = wilcox_stat(gene_stat[l_set], gene_stat[!l_set])\n    } else if(method == \"chisq\") {\n        # should on work with binary gene-level statistics\n        stat = chisq_stat(gene_stat, l_set)\n    } else {\n        stop(\"method is not supported.\")\n    }\n    \n    return(stat)\n}"},{"path":"gsea-framework.html","id":"geneset-to-be-a-list-of-gene-sets","chapter":"6 GSEA framework","heading":"6.5 geneset to be a list of gene sets","text":"Check new version gsea_tiny():Now gsea_tiny(), can also generate null distribution set-level statistics, just \ngenerating random matrices.better design integrate permutation procedures inside gsea_tiny(). first integrate sample permutation:Let’s try. actually quite slow run 1000 permutations.basic procedures developing new R functions. First make sure functions working, next optimize functions let running faster use less memory.gsea_tiny() running 100 permutations needs several seconds.package profvis provides easy profiling.can see process %% uses quite lot running time.can first calculate relations genes sets later can repeatedly used.Now faster 1000 permutations:support gene permutation, need permute gene-level statistics calculated original matrix.\nNote also move position geneset argument start argument list must-set argument.Let’s check:Note, settings can detect -regulated gene sets.Great! think combination gene-level method, gene-level transformation set-level method GSEA method, gsea_tiny() actually already support many GSEA methods! whole functionality contains 180 lines code (https://gist.github.com/jokergoo/e8fff4a57ec59efc694b9e730da22b9f).","code":"\n# geneset: a list of vectors (gene IDs)\ngsea_tiny = function(mat, condition, \n    gene_level_method = \"tvalue\", transform = \"none\", binarize = function(x) x,\n    gene_stat, set_level_method = \"mean\", geneset) {\n    \n    gene_stat = gene_level(mat, condition, method = gene_level_method, \n        transform = transform, binarize = binarize)\n    \n    set_stat = sapply(geneset, function(set) {\n        l_set = rownames(mat) %in% set\n        \n        set_level(gene_stat, l_set, set_level_method)\n    })\n    \n    return(set_stat)\n}\nss = gsea_tiny(expr, condition, geneset = gs)\nhead(ss)\n#          41bbPathway          ace2Pathway acetaminophenPathway \n#           -0.3125486            1.2710342            0.3441254 \n#           achPathway \n#           -0.2944815\n# sample permutation\nss_random = list()\nfor(i in 1:1000) {\n    ss_random[[i]] = gsea_tiny(mat, sample(condition), geneset = gs)\n}\n\n# or gene permutation\nfor(i in 1:1000) {\n    mat2 = mat\n    rownames(mat2) = sample(rownames(mat))\n    ss_random[[i]] = gsea_tiny(mat2, condition, geneset = gs)\n}\ngsea_tiny = function(mat, condition, \n    gene_level_method = \"tvalue\", transform = \"none\", binarize = function(x) x,\n    gene_stat, set_level_method = \"mean\", geneset,\n    nperm = 1000) {\n    \n    gene_stat = gene_level(mat, condition, method = gene_level_method, \n        transform = transform, binarize = binarize)\n    \n    set_stat = sapply(geneset, function(set) {\n        l_set = rownames(mat) %in% set\n        \n        set_level(gene_stat, l_set, set_level_method)\n    })\n    \n    ## null distribution \n    set_stat_random = list()\n    \n    for(i in seq_len(nperm)) {\n        condition2 = sample(condition)\n        gene_stat = gene_level(mat, condition2, method = gene_level_method, \n            transform = transform, binarize = binarize)\n        \n        set_stat_random[[i]] = sapply(geneset, function(set) {\n            l_set = rownames(mat) %in% set\n            \n            set_level(gene_stat, l_set, set_level_method)\n        })\n        \n        if(i %% 100 == 0) {\n            message(i, \" permutations done.\")\n        }\n    }\n    \n    set_stat_random = do.call(cbind, set_stat_random)\n    \n    n_set = length(geneset)\n    p = numeric(n_set)\n    for(i in seq_len(n_set)) {\n        p[i] = sum(set_stat_random[i, ] >= set_stat[i])/nperm\n    }\n    \n    # the function returns a data frame\n    df = data.frame(stat = set_stat,\n                    size = sapply(geneset, length), \n                    p.value = p)\n    df$fdr = p.adjust(p, \"BH\")\n    \n    return(df)\n}\ndf = gsea_tiny(expr, condition, geneset = gs)\ndf = gsea_tiny(expr, condition, geneset = gs, nperm = 100)\nlibrary(profvis)\nprofvis(gsea_tiny(expr, condition, geneset = gs, nperm = 100))\ngsea_tiny = function(mat, condition, \n    gene_level_method = \"tvalue\", transform = \"none\", binarize = function(x) x,\n    gene_stat, set_level_method = \"mean\", geneset,\n    nperm = 1000) {\n    \n    gene_stat = gene_level(mat, condition, method = gene_level_method, \n        transform = transform, binarize = binarize)\n    \n    # now this only needs to be calculated once\n    l_set_list = lapply(geneset, function(set) {\n        rownames(mat) %in% set\n    })\n    \n    set_stat = sapply(l_set_list, function(l_set) {\n        set_level(gene_stat, l_set, set_level_method)\n    })\n    \n    ## null distribution \n    set_stat_random = list()\n    \n    for(i in seq_len(nperm)) {\n        condition2 = sample(condition)\n        gene_stat_random = gene_level(mat, condition2, method = gene_level_method, \n            transform = transform, binarize = binarize)\n        \n        # here we directly use l_set_list\n        set_stat_random[[i]] = sapply(l_set_list, function(l_set) {\n            set_level(gene_stat_random, l_set, set_level_method)\n        })\n        \n        if(i %% 100 == 0) {\n            message(i, \" permutations done.\")\n        }\n    }\n    \n    set_stat_random = do.call(cbind, set_stat_random)\n    \n    n_set = length(geneset)\n    p = numeric(n_set)\n    for(i in seq_len(n_set)) {\n        p[i] = sum(set_stat_random[i, ] >= set_stat[i])/nperm\n    }\n    \n    df = data.frame(stat = set_stat,\n                    size = sapply(geneset, length), \n                    p.value = p)\n    df$fdr = p.adjust(p, \"BH\")\n    \n    return(df)\n}\ndf = gsea_tiny(expr, condition, geneset = gs)\ngsea_tiny = function(mat, condition, geneset,\n    gene_level_method = \"tvalue\", transform = \"none\", binarize = function(x) x,\n    gene_stat, set_level_method = \"mean\",\n    nperm = 1000, perm_type = \"sample\") {\n    \n    gene_stat = gene_level(mat, condition, method = gene_level_method, \n        transform = transform, binarize = binarize)\n    l_set_list = lapply(geneset, function(set) {\n        rownames(mat) %in% set\n    })\n    \n    set_stat = sapply(l_set_list, function(l_set) {\n        set_level(gene_stat, l_set, set_level_method)\n    })\n    \n    ## null distribution \n    set_stat_random = list()\n    \n    for(i in seq_len(nperm)) {\n        \n        if(perm_type == \"sample\") {\n            condition2 = sample(condition)\n            gene_stat_random = gene_level(mat, condition2, method = gene_level_method, \n                transform = transform, binarize = binarize)\n            \n            set_stat_random[[i]] = sapply(l_set_list, function(l_set) {\n                set_level(gene_stat_random, l_set, set_level_method)\n            })\n        } else if(perm_type == \"gene\") {\n            gene_stat_random = sample(gene_stat)\n            \n            set_stat_random[[i]] = sapply(l_set_list, function(l_set) {\n                set_level(gene_stat_random, l_set, set_level_method)\n            })\n        } else {\n            stop(\"wrong permutation type.\")\n        }\n        \n        if(i %% 100 == 0) {\n            message(i, \" permutations done.\")\n        }\n    }\n    \n    set_stat_random = do.call(cbind, set_stat_random)\n    \n    n_set = length(geneset)\n    p = numeric(n_set)\n    for(i in seq_len(n_set)) {\n        p[i] = sum(set_stat_random[i, ] >= set_stat[i])/nperm\n    }\n    \n    df = data.frame(stat = set_stat,\n                    size = sapply(geneset, length), \n                    p.value = p)\n    df$fdr = p.adjust(p, \"BH\")\n    \n    return(df)\n}\nset.seed(123)\ndf1 = gsea_tiny(expr, condition, geneset = gs, perm_type = \"sample\")\ndf2 = gsea_tiny(expr, condition, geneset = gs, perm_type = \"gene\")\ndf1 = df1[order(df1$p.value), ]\ndf2 = df2[order(df2$p.value), ]\nhead(df1)\n#                        stat size p.value fdr\n# hsp27Pathway      1.1077565   16       0   0\n# p53hypoxiaPathway 0.8476668   20       0   0\n# p53Pathway        1.1781147   16       0   0\n# HTERT_DOWN        0.3002211   67       0   0\nhead(df2)\n#                    stat size p.value fdr\n# ace2Pathway   1.2710342   12       0   0\n# inflamPathway 0.7852193   29       0   0\n# p53Pathway    1.1781147   16       0   0\n# P53_UP        0.9864715   40       0   0"},{"path":"gsea-framework.html","id":"current-tools-for-gsea-framework","chapter":"6 GSEA framework","heading":"6.6 current tools for GSEA framework","text":"Package EnrichmentBrowser integrates lot GSEA methods. integrated methods :EnrichmentBrowser needs special format (SummarizedExperiment) input.\nCondition labels stored column “GROUP.” Log2 fold change adjusted p-values saved “FC” “ADJ.PVAL” columns.Note, run eaBrowse(), need explicitly convert ENTREZID.load hallmark gene sets package msigdbr.using Entrez ID, make sure “numbers” converted “characters.”Simply call sbea() function specific method:Note now can use eaBowse(res) create tiny website detailed results.Next run supported GSEA methods EnrichmentBrowser.compare significant gene sets different methods.","code":"\nlibrary(EnrichmentBrowser)\nsbeaMethods()\n#  [1] \"ora\"        \"safe\"       \"gsea\"       \"gsa\"        \"padog\"     \n#  [6] \"globaltest\" \"roast\"      \"camera\"     \"gsva\"       \"samgs\"     \n# [11] \"ebm\"        \"mgsa\"\nlibrary(CePa)\ncondition = read.cls(\"data/P53.cls\", treatment = \"MUT\", control = \"WT\")$label\nexpr = read.gct(\"data/P53_collapsed_symbols.gct\")\n\n\nlibrary(SummarizedExperiment)\nse = SummarizedExperiment(assays = SimpleList(expr = expr))\ncolData(se) = DataFrame(GROUP = ifelse(condition == \"WT\", 1, 0))\n\nl = condition == \"WT\"\n\nlibrary(genefilter)\ntdf = rowttests(expr, factor(condition))\nrowData(se) = DataFrame(FC = log2(rowMeans(expr[, l])/rowMeans(expr[, !l])),\n                        ADJ.PVAL = p.adjust(tdf$p.value))\nse\n# class: SummarizedExperiment \n# dim: 10100 50 \n# metadata(0):\n# assays(1): expr\n# rownames(10100): TACC2 C14orf132 ... AMACR LDLR\n# rowData names(2): FC ADJ.PVAL\n# colnames: NULL\n# colData names(1): GROUP\nse = idMap(se, org = \"hsa\", from = \"SYMBOL\", to = \"ENTREZID\")  # !! Gene ID must be converted to EntrezID\nlibrary(msigdbr)\ngs = msigdbr(category = \"H\")\ngs = split(gs$human_entrez_gene, gs$gs_name)  # Entrez ID must be used\ngs = lapply(gs, as.character)                 # be careful Entrez ID might be wrongly used as integers, convert them into characters\nres = sbea(method = \"gsea\", se = se, gs = gs)\ntb = gsRanking(res, signif.only = FALSE)\nall_gsea_methods = sbeaMethods()\nall_gsea_methods\n#  [1] \"ora\"        \"safe\"       \"gsea\"       \"gsa\"        \"padog\"     \n#  [6] \"globaltest\" \"roast\"      \"camera\"     \"gsva\"       \"samgs\"     \n# [11] \"ebm\"        \"mgsa\"\nall_gsea_methods = setdiff(all_gsea_methods, \"padog\")\nres_list = lapply(all_gsea_methods, function(method) {\n    sbea(method = method, se = se, gs = gs)\n})\nnames(res_list) = all_gsea_methods\ntb_list = lapply(res_list, gsRanking)\ntb_list\n# $ora\n# DataFrame with 23 rows and 4 columns\n#                   GENE.SET GLOB.STAT NGLOB.STAT      PVAL\n#                <character> <numeric>  <numeric> <numeric>\n# 1     HALLMARK_P53_PATHWAY         2    0.01480     0.001\n# 2       HALLMARK_APOPTOSIS         2    0.01420     0.001\n# 3   HALLMARK_PI3K_AKT_MT..         1    0.01250     0.001\n# 4   HALLMARK_INTERFERON_..         1    0.00730     0.001\n# 5      HALLMARK_MYOGENESIS         1    0.00592     0.002\n# ...                    ...       ...        ...       ...\n# 19  HALLMARK_REACTIVE_OX..         0          0     0.023\n# 20  HALLMARK_INTERFERON_..         0          0     0.026\n# 21  HALLMARK_TGF_BETA_SI..         0          0     0.029\n# 22  HALLMARK_ANDROGEN_RE..         0          0     0.039\n# 23  HALLMARK_CHOLESTEROL..         0          0     0.044\n# \n# $safe\n# DataFrame with 2 rows and 4 columns\n#                 GENE.SET GLOB.STAT NGLOB.STAT      PVAL\n#              <character> <numeric>  <numeric> <numeric>\n# 1   HALLMARK_P53_PATHWAY    225000       1660     0.021\n# 2 HALLMARK_HEDGEHOG_SI..     51300       1830     0.033\n# \n# $gsea\n# DataFrame with 1 row and 4 columns\n#               GENE.SET        ES       NES      PVAL\n#            <character> <numeric> <numeric> <numeric>\n# 1 HALLMARK_P53_PATHWAY     0.355       1.5    0.0421\n# \n# $gsa\n# DataFrame with 2 rows and 3 columns\n#                 GENE.SET     SCORE      PVAL\n#              <character> <numeric> <numeric>\n# 1   HALLMARK_P53_PATHWAY     0.388     0.012\n# 2 HALLMARK_IL6_JAK_STA..     0.455     0.020\n# \n# $globaltest\n# DataFrame with 1 row and 3 columns\n#                 GENE.SET      STAT      PVAL\n#              <character> <numeric> <numeric>\n# 1 HALLMARK_IL6_JAK_STA..      4.41     0.008\n# \n# $roast\n# DataFrame with 3 rows and 4 columns\n#                 GENE.SET  NR.GENES       DIR      PVAL\n#              <character> <numeric> <numeric> <numeric>\n# 1   HALLMARK_P53_PATHWAY       135         1  0.000999\n# 2 HALLMARK_ALLOGRAFT_R..       168         1  0.038000\n# 3 HALLMARK_HEDGEHOG_SI..        28         1  0.040000\n# \n# $camera\n# DataFrame with 8 rows and 4 columns\n#                 GENE.SET  NR.GENES       DIR      PVAL\n#              <character> <numeric> <numeric> <numeric>\n# 1 HALLMARK_G2M_CHECKPO..       142        -1  0.000412\n# 2 HALLMARK_ALLOGRAFT_R..       168         1  0.000824\n# 3   HALLMARK_E2F_TARGETS       129        -1  0.001960\n# 4 HALLMARK_MITOTIC_SPI..       116        -1  0.011800\n# 5   HALLMARK_P53_PATHWAY       135         1  0.014700\n# 6 HALLMARK_PROTEIN_SEC..        80        -1  0.022000\n# 7 HALLMARK_KRAS_SIGNAL..       124         1  0.022900\n# 8 HALLMARK_UV_RESPONSE..       122        -1  0.028800\n# \n# $gsva\n# DataFrame with 3 rows and 3 columns\n#                 GENE.SET   t.SCORE      PVAL\n#              <character> <numeric> <numeric>\n# 1 HALLMARK_WNT_BETA_CA..     -2.12    0.0389\n# 2 HALLMARK_HEDGEHOG_SI..      2.12    0.0390\n# 3   HALLMARK_P53_PATHWAY      2.06    0.0445\n# \n# $samgs\n# DataFrame with 7 rows and 4 columns\n#                 GENE.SET SUMSQ.STAT NSUMSQ.STAT      PVAL\n#              <character>  <numeric>   <numeric> <numeric>\n# 1   HALLMARK_P53_PATHWAY        322        2.38     0.000\n# 2     HALLMARK_APOPTOSIS        257        1.83     0.003\n# 3 HALLMARK_HEDGEHOG_SI..         50        1.78     0.012\n# 4    HALLMARK_MYOGENESIS        245        1.45     0.017\n# 5 HALLMARK_INTERFERON_..        209        1.52     0.024\n# 6 HALLMARK_INFLAMMATOR..        218        1.36     0.025\n# 7 HALLMARK_TNFA_SIGNAL..        226        1.44     0.041\n# \n# $ebm\n# NULL\n# \n# $mgsa\n# NULL\ntb_list = tb_list[sapply(tb_list, length) > 0]\n\nlibrary(ComplexHeatmap)\ncm = make_comb_mat(lapply(tb_list, function(x) x[[1]]))\nUpSet(cm,\n    top_annotation = upset_top_annotation(cm, add_numbers = TRUE),\n    right_annotation = upset_right_annotation(cm, add_numbers = TRUE)\n)"},{"path":"gsea-framework.html","id":"important-aspects-of-gsea-methogology","chapter":"6 GSEA framework","heading":"6.7 Important aspects of GSEA methogology","text":"Sample size general factor stastics samples give pwoer statistical tests.Gene sets differnet sizes. affect teh null distribution (mostly standard deviation) set-level statisticIn ORA, assumes genes independent, also parametric methods, xxx, also assume … However, ignore \ngene correlation , moslty estimate wrong varaince. Nevertheless, suggest use sample permutation keeps \ngene correlation structure xxx","code":""},{"path":"gsea-framework.html","id":"recommandations-of-methods","chapter":"6 GSEA framework","heading":"6.8 recommandations of methods","text":"Due test information reduction matrix sigle value,use GSEA methoduse sample permutationuse self-contained setleveluse simply modelAdditionally, also recommneded general data ananlysis, explorrary data anlaysi (EDA) first applied , eg..\ncheck global direrential expression, helps find proper method.list genes, use ORA hypergeometric distribution set whole protaincoding genes backgroundIf vector pre-computed gene-level scores, use GSEA tool gene-permutation version. suggested first check\nglobal distribution gene level scores…yo uhave complete matrix, use GSEA sample permutations","code":""},{"path":"gene-set-enrichment-analysis-in-genomics.html","id":"gene-set-enrichment-analysis-in-genomics","chapter":"7 Gene Set Enrichment Analysis in Genomics","heading":"7 Gene Set Enrichment Analysis in Genomics","text":"","code":""},{"path":"gene-set-enrichment-analysis-in-genomics.html","id":"overview-4","chapter":"7 Gene Set Enrichment Analysis in Genomics","heading":"7.1 Overview","text":"Given list genomic regions, biological functions \nrelate. nature solution first annotate genomic regions nearest\nTSS, use genes certain distance ORA analysis. \nchapter, discuss problems directly apply ORA genomic data\nsolutions.","code":""},{"path":"gene-set-enrichment-analysis-in-genomics.html","id":"the-great-method","chapter":"7 Gene Set Enrichment Analysis in Genomics","heading":"7.2 The GREAT method","text":"Genomics epigenomics studies always generate lists genomic regions interests. example, whole genome sequencing whole exon sequencing generate lists SNVs Indels. ChIPseq generates list peaks regions certain histone signals enriched . Whole genome bisultite sequencing data generates diffefrentially methylated regions, methylation level, generates lowly-methylated partially methylated domains. analysis go next step, biological functions assoicated regions. related biologycal meaning xxx. Since functional enrichment genes gene sets, natural way answer questions link genomic regions genes, looking nearest genes gene regions, apply mapping regions -> genes, list regions, list associated genes. ORA can applied test enrichment genes asspciated regions genes teh background (genes genome).conversion straightforward, however, let’s recall null assumption ORA. ORA, genes treated balls genes probability independently picked. However, mapping regions genes, mapping regions genes balanced. Let’s go back regions, actually, assume, null hypotheiss, genomic regions distrbuted uniformly genome, converting genes, due somes regions locate gene desert reginos locates close genes, results genes assigned wth probability picked. exampe, clusters regions close gene, genes likely picked. thus genes different weights. violates null assumption ORA. inproper comvertion produce false positive results.Recall straighgy proposed convert regions genes, since proper region gene step, tool GREAT proposes directly constrcut region sets, list regions associated biological term, apply enrichment tests input regions region set. solves xxx. following sections, first intruduce construct region sets enrichment tests.","code":""},{"path":"gene-set-enrichment-analysis-in-genomics.html","id":"construct-region-sets","chapter":"7 Gene Set Enrichment Analysis in Genomics","heading":"7.2.1 Construct region sets","text":"gene set, GREAT directly constructs “region sets” (genomic domains) associate individual biological functions. GREAT, three modes linking regions genesBasal plus extensionBasal plus extensionTwo nearest genesTwo nearest genessingle nearest genesingle nearest gene","code":""},{"path":"gene-set-enrichment-analysis-in-genomics.html","id":"the-binomial-model","chapter":"7 Gene Set Enrichment Analysis in Genomics","heading":"7.2.2 The binomial model","text":"enrichment test applied follows. specific biological term represented gene set, denote fraction associated functional domains genome (Fig. 1C) p, total number input regions N, observed number input regions fall associated domains n corresponding random variable X, X follows binomial distribution: X ~ B(p, N) p-value enrichment calculated Pr(X ≥ n)Note GREAT, input regions treated single points middle points used.","code":""},{"path":"gene-set-enrichment-analysis-in-genomics.html","id":"the-hypergeometric-model-when-dealing-with-background","chapter":"7 Gene Set Enrichment Analysis in Genomics","heading":"7.2.3 The hypergeometric model when dealing with background","text":"GREAT also supports background. “background” like universal sets super sets input regions.","code":""},{"path":"gene-set-enrichment-analysis-in-genomics.html","id":"implementation","chapter":"7 Gene Set Enrichment Analysis in Genomics","heading":"7.2.4 implementation","text":"","code":"\nlibrary(rGREAT)\ngr = randomRegions(genome = \"hg19\")\n\nlibrary(TxDb.Hsapiens.UCSC.hg19.knownGene)\ng = genes(TxDb.Hsapiens.UCSC.hg19.knownGene)\ng = g[seqnames(g) %in% paste0(\"chr\", c(1:22, \"X\", \"Y\"))]\n\nall_chr = paste0(\"chr\", c(1:22, \"X\", \"Y\"))\nseqlevels(gr) = all_chr\nseqlevels(g) = all_chr\n\nextended_tss = extendTSS(g)\n\ngs = sample(g$gene_id, 100)\n\nregion_set = extended_tss[extended_tss$gene_id %in% gs]\nregion_set = reduce(region_set)\n\ngr_mid = gr\nstart(gr_mid) = end(gr_mid) = mid(gr)\nov = findOverlaps(gr_mid, region_set)\n\nn_total = length(gr)\nprop = sum(width(region_set))/sum( seqlengths(extended_tss))\nn_hits = length(ov)\n\np = 1 - pbinom(n_hits - 1, n_total, prop)"},{"path":"gene-set-enrichment-analysis-in-genomics.html","id":"the-web-based-tool","chapter":"7 Gene Set Enrichment Analysis in Genomics","heading":"7.2.5 The web-based tool","text":"GREAT implemented web-based tool. use straightforward.","code":""},{"path":"gene-set-enrichment-analysis-in-genomics.html","id":"the-rgreat-package","chapter":"7 Gene Set Enrichment Analysis in Genomics","heading":"7.2.6 The rGREAT package","text":"GREAT web service useful xxx, xxx. rGREAT package can make GREAT analysis automatic automaticlaly submitting genomic regions GREAT web service retrieve results fly.","code":""},{"path":"gene-set-enrichment-analysis-in-genomics.html","id":"local-great-analysis","chapter":"7 Gene Set Enrichment Analysis in Genomics","heading":"7.3 Local GREAT analysis","text":"GREAT, although popular tool,extension","code":""},{"path":"gene-set-enrichment-analysis-in-genomics.html","id":"rnaseq-and-methylation-adjusted-ora","chapter":"7 Gene Set Enrichment Analysis in Genomics","heading":"7.4 RNASeq and methylation-adjusted ORA","text":"","code":""},{"path":"gene-set-enrichment-analysis-in-genomics.html","id":"snp-based-gsea","chapter":"7 Gene Set Enrichment Analysis in Genomics","heading":"7.5 SNP-based GSEA","text":"","code":""},{"path":"gene-set-enrichment-analysis-in-genomics.html","id":"general-comments","chapter":"7 Gene Set Enrichment Analysis in Genomics","heading":"7.6 general comments","text":"E.g. large sample sizecompare different sets genomic regions","code":""},{"path":"topology-based-pathway-enrichmetn.html","id":"topology-based-pathway-enrichmetn","chapter":"8 Topology-based pathway enrichmetn","heading":"8 Topology-based pathway enrichmetn","text":"","code":""},{"path":"topology-based-pathway-enrichmetn.html","id":"overview-5","chapter":"8 Topology-based pathway enrichmetn","heading":"8.1 Overview","text":"Gene sets represented vector ","code":""},{"path":"topology-based-pathway-enrichmetn.html","id":"use-topology-informatino","chapter":"8 Topology-based pathway enrichmetn","heading":"8.2 Use topology informatino","text":"","code":""},{"path":"topology-based-pathway-enrichmetn.html","id":"pathway-common-structure","chapter":"8 Topology-based pathway enrichmetn","heading":"8.3 Pathway common structure","text":"","code":""},{"path":"topology-based-pathway-enrichmetn.html","id":"general-process-of-utilizing-topology-information","chapter":"8 Topology-based pathway enrichmetn","heading":"8.4 General process of utilizing topology information","text":"","code":""},{"path":"topology-based-pathway-enrichmetn.html","id":"centrality-measures","chapter":"8 Topology-based pathway enrichmetn","heading":"8.5 Centrality measures","text":"","code":""},{"path":"topology-based-pathway-enrichmetn.html","id":"centrality-based-pathway-enrichment","chapter":"8 Topology-based pathway enrichmetn","heading":"8.6 centrality-based pathway enrichment","text":"","code":""},{"path":"topology-based-pathway-enrichmetn.html","id":"spia-pathway-impact-analysis","chapter":"8 Topology-based pathway enrichmetn","heading":"8.7 SPIA: pathway impact analysis","text":"","code":""},{"path":"topology-based-pathway-enrichmetn.html","id":"r-packages-for-topology-based-gsea","chapter":"8 Topology-based pathway enrichmetn","heading":"8.8 R packages for topology-based GSEA","text":"","code":""},{"path":"extensions-of-gsea.html","id":"extensions-of-gsea","chapter":"9 Extensions of GSEA","heading":"9 Extensions of GSEA","text":"","code":""},{"path":"extensions-of-gsea.html","id":"single-sample-based-gsea","chapter":"9 Extensions of GSEA","heading":"9.1 Single sample-based GSEA","text":"","code":""},{"path":"extensions-of-gsea.html","id":"ensembles-of-multiple-gsea-methods","chapter":"9 Extensions of GSEA","heading":"9.2 Ensembles of multiple GSEA methods","text":"","code":""},{"path":"extensions-of-gsea.html","id":"tba","chapter":"9 Extensions of GSEA","heading":"9.3 TBA","text":"","code":""},{"path":"visualization.html","id":"visualization","chapter":"10 Visualization","heading":"10 Visualization","text":"","code":""},{"path":"visualization.html","id":"general-xxx","chapter":"10 Visualization","heading":"10.1 general xxx","text":"","code":""},{"path":"visualization.html","id":"visualize-by-statistical-plots","chapter":"10 Visualization","heading":"10.2 Visualize by statistical plots","text":"","code":""},{"path":"visualization.html","id":"network-visualization","chapter":"10 Visualization","heading":"10.3 network visualization","text":"","code":""},{"path":"visualization.html","id":"enrichment-map","chapter":"10 Visualization","heading":"10.4 Enrichment map","text":"","code":""},{"path":"visualization.html","id":"section","chapter":"10 Visualization","heading":"10.5 ","text":"","code":""},{"path":"clustering-and-simplifying-gsea-results.html","id":"clustering-and-simplifying-gsea-results","chapter":"11 Clustering and simplifying GSEA results","heading":"11 Clustering and simplifying GSEA results","text":"","code":""},{"path":"clustering-and-simplifying-gsea-results.html","id":"overview-6","chapter":"11 Clustering and simplifying GSEA results","heading":"11.1 Overview","text":"Functional enrichment becoming standard analysis xxx","code":""},{"path":"clustering-and-simplifying-gsea-results.html","id":"measures-of-similarities","chapter":"11 Clustering and simplifying GSEA results","heading":"11.2 measures of similarities","text":"","code":""},{"path":"clustering-and-simplifying-gsea-results.html","id":"overlap-based","chapter":"11 Clustering and simplifying GSEA results","heading":"11.2.1 overlap-based","text":"Show terms tend show high similarity, parent-child, siblinds","code":""},{"path":"clustering-and-simplifying-gsea-results.html","id":"semantic-measures","chapter":"11 Clustering and simplifying GSEA results","heading":"11.2.2 semantic measures","text":"","code":""},{"path":"clustering-and-simplifying-gsea-results.html","id":"ic","chapter":"11 Clustering and simplifying GSEA results","heading":"11.2.2.1 IC","text":"","code":"\ngo_id_1 = \"GO:0032888\"\ngo_id_2 = \"GO:0051256\"\nlibrary(org.Hs.eg.db)\ntb = toTable(org.Hs.egGO2ALLEGS)\ntb = tb[tb$Ontology == \"BP\", , drop = FALSE]\ngo_gene_sets = split(tb$gene_id, tb$go_id)\n\nlibrary(GO.db)\noffspring = as.list(GOBPOFFSPRING)\nn = sum(sapply(c(go_id_1, offspring[[go_id_1]]), function(id) {\n    length(go_gene_sets[[id]])\n}), na.rm = TRUE)\nn_bg = sum(sapply(go_gene_sets, length))\n-log(n/n_bg)\n# [1] 13.91922\ncalc_IC = function(go_id) {\n    n = sum(sapply(c(go_id, offspring[[go_id]]), function(id) {\n        length(go_gene_sets[[id]])\n    }), na.rm = TRUE)\n    n_bg = sum(sapply(go_gene_sets, length))\n    -log(n/n_bg)\n}\nIC_1 = calc_IC(go_id_1)\nIC_2 = calc_IC(go_id_2)\nCA = intersect(GOBPANCESTOR[[go_id_1]], GOBPANCESTOR[[go_id_2]])\nCA = setdiff(CA, \"all\")\nIC_MICA = max(sapply(CA, calc_IC))\n2*IC_MICA/(IC_1 + IC_2)\n# [1] 0.8660491"},{"path":"clustering-and-simplifying-gsea-results.html","id":"enrichment-map-1","chapter":"11 Clustering and simplifying GSEA results","heading":"11.3 Enrichment map","text":"","code":""},{"path":"clustering-and-simplifying-gsea-results.html","id":"david","chapter":"11 Clustering and simplifying GSEA results","heading":"11.4 David","text":"","code":""},{"path":"clustering-and-simplifying-gsea-results.html","id":"simplifyenrichment","chapter":"11 Clustering and simplifying GSEA results","heading":"11.5 simplifyEnrichment","text":"","code":""}]
